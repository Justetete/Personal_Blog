-- MySQL dump 10.13  Distrib 8.0.38, for macos14 (arm64)
--
-- Host: 127.0.0.1    Database: myblog_db
-- ------------------------------------------------------
-- Server version	8.0.39

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `tb_admin_user`
--

DROP TABLE IF EXISTS `tb_admin_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_admin_user` (
  `admin_user_id` int NOT NULL AUTO_INCREMENT COMMENT '管理员id',
  `login_user_name` varchar(50) NOT NULL COMMENT '管理员登陆名称',
  `login_password` varchar(50) NOT NULL COMMENT '管理员登陆密码',
  `nick_name` varchar(50) NOT NULL COMMENT '管理员显示昵称',
  `locked` tinyint DEFAULT '0' COMMENT '是否锁定 0未锁定 1已锁定无法登陆',
  PRIMARY KEY (`admin_user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_admin_user`
--

LOCK TABLES `tb_admin_user` WRITE;
/*!40000 ALTER TABLE `tb_admin_user` DISABLE KEYS */;
INSERT INTO `tb_admin_user` VALUES (1,'admin','e10adc3949ba59abbe56e057f20f883e','vigilr',0);
/*!40000 ALTER TABLE `tb_admin_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_blog`
--

DROP TABLE IF EXISTS `tb_blog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_blog` (
  `blog_id` bigint NOT NULL AUTO_INCREMENT COMMENT '博客表主键id',
  `blog_title` varchar(200) NOT NULL COMMENT '博客标题',
  `blog_summary` varchar(500) NOT NULL COMMENT '博客摘要',
  `blog_content` mediumtext NOT NULL COMMENT '博客内容',
  `blog_category_id` int NOT NULL COMMENT '博客分类id',
  `blog_category_name` varchar(50) NOT NULL COMMENT '博客分类(冗余字段)',
  `blog_tags` varchar(200) NOT NULL COMMENT '博客标签',
  `blog_status` tinyint NOT NULL DEFAULT '0' COMMENT '0-草稿 1-发布',
  `blog_views` bigint NOT NULL DEFAULT '0' COMMENT '阅读量',
  `enable_comment` tinyint NOT NULL DEFAULT '0' COMMENT '0-允许评论 1-不允许评论',
  `is_deleted` tinyint NOT NULL DEFAULT '0' COMMENT '是否删除 0=否 1=是',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '添加时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`blog_id`)
) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_blog`
--

LOCK TABLES `tb_blog` WRITE;
/*!40000 ALTER TABLE `tb_blog` DISABLE KEYS */;
INSERT INTO `tb_blog` VALUES (1,'批量重命名音乐文件','批量重命名音乐文件  从酷狗音乐下载音乐时，发现下载的音乐的文件名都是以歌手开头，看着很难受，而且在酷狗的下载设置里没有下载的文件名设置。 简而言之这个小程序就是将文件名为歌手 - 音乐名.后缀的音乐文件批量修改为音乐名-歌手.后缀的样式  先看下效果','# 批量重命名音乐文件\n\n从酷狗音乐下载音乐时，发现下载的音乐的文件名都是以歌手开头，看着很难受，而且在酷狗的下载设置里没有下载的文件名设置。\n\n简而言之这个小程序就是将文件名为`歌手 - 音乐名.后缀`的音乐文件批量修改为`音乐名-歌手.后缀`的样式\n\n先看下效果\n\n![实现效果](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nL1JlbmFtZU11c2ljLmdpZg)\n\n### 思路\n\n1. 获取音乐文件\n2. 利用正则改名\n3. 文件改名\n4. 简单地设计一下界面\n\n### 详细步骤\n\n<font color=#00f>1. 先设计核心代码，重命名</font>\n\n   例如`周杰伦 - 青花瓷.flac`文件就需要把他改为`青花瓷-周杰伦.flac`（修改之前的文件名是包含空格的）\n\n```java\npublic static String getNewName(String oldName) {\n    String newName;\n    //去掉字符串的所有空格\n    newName = oldName.replaceAll(\" \", \"\");\n    //分离歌手，歌名，文件后缀\n    String[] results = newName.split(\"-|\\\\.\");\n    //连接新的字符串\n    if (results.length == 3) {\n        newName = results[1] + \"-\" + results[0] + \".\" + results[2];\n    }\n    return newName;\n}\n```\n\n本方法传入的形参为要修改的文件名，返回修改后的文件名\n\n<font color=#00f>2. 设计重命名单个文件的方法</font>\n\n```java\npublic static void rename(File file, String fileName) {\n    //文件类型不是目录\n    if (!file.isDirectory()) {\n        File newFile = new File(file.getParent(), fileName);\n        file.renameTo(newFile);\n        System.out.println(\"修改完成：\" + newFile.getName());\n    }\n}\n```\n\n传入的形参为文件和修改后的文件名\n\n<font color=#00f>3. 重命名音乐目录下的文件</font>\n\n```java\npublic static void renameMusicDirectory(File directoryFile) {\n    if (directoryFile.isDirectory()) {\n        File[] results = directoryFile.listFiles();\n        for (int i = 0; i < results.length; i++) {\n            if (results[i].isFile()) {\n                String newName = getNewName(results[i].getName());\n                System.out.println(\"修改前的名称：\" + results[i].getName());\n                rename(results[i], newName);\n            }\n        }\n    }\n}\n```\n\n参数只需传入文件目录即可，然后循环调用单个文件重命名的方法即可\n\n **源码已上传至本人的[GitHub仓库](https://github.com/eternidad33/MyTools-mini/tree/master/RenameMusic) ，欢迎访问**。\n \n> 也可以花费5个积分通过[CSDN](https://download.csdn.net/download/qq_42907802/12332919)下载，支持我一下!',25,'开发','java',1,713,0,0,'2020-04-17 10:08:03','2020-04-17 10:08:03'),(2,'将仓库的文件转换成 Markdown 格式的链接','在GitHub的README文件中为自己的文章生成目录，由于一行一行的重复类似的代码，一个一个的打字比较麻烦，所以就想到设计一个程序转换Markdown格式。  先看效果:','在GitHub的README文件中为自己的文章生成目录，由于一行一行的重复类似的代码，一个一个的打字比较麻烦，所以就想到设计一个程序转换Markdown格式。\n\n先看效果:\n\n![toMDLink](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nL3RvTURMaW5rLmdpZg)\n\n\n### 思路\n\n1. 获取文件目录\n2. 将其中的文件名转换成`[文件名](文件路径)`格式\n3. 输出运行结果\n\n### 步骤\n\n<font color=#00f size=5>1. 定义将文件转换成Markdown链接格式的方法</font>\n\n例如articles目录下的文件`Java进阶-数组.ipynb`文件转换为Markdown格式的链接为`[Java进阶-数组](/articles/Java进阶-数组.ipynb)`\n\n```java\npublic static String toMDLink(File file) {\n    String fileName = file.getName();\n    String fileParentName = file.getParentFile().getName();\n    return \"- [\" + fileName.substring(0, fileName.lastIndexOf(\'.\')) + \"](/\" + fileParentName + \'/\' + fileName + \")\";\n}\n```\n\n可以将链接拆成`[ `，`去后缀的文件名`，`](/`，`父目录名`，`/`，``文件名`，`)`\n\n只需获取到`去后缀的文件名`，`父目录名`和`文件名`即可\n\n文件名：`file.getName()`\n\n父目录名：`file.getParentFile().getName()`\n\n去后缀的文件名：`fileName.substring(0, fileName.lastIndexOf(\'.\'))`\n\n<font color=#00f size=5>2. 将文件夹中的所有文件转换成Markdown链接</font>\n\n```java\npublic static StringBuffer getStringBuffer(String str) {\n    StringBuffer sb = new StringBuffer();\n    File file = new File(str);\n    if (file.isDirectory()) {\n        File[] results = file.listFiles();\n        for (int i = 0; i < results.length; i++) {\n            if (results[i].isFile()) {\n                sb.append(toMDLink(results[i])).append(\'\\n\');\n            }\n        }\n    }\n    return sb;\n}\n```\n\n参数为目录的路径，遍历该目录下的所有文件，并把转换后的字符串保存在`StringBuffer`对象中，每个结果用`\\n`换行以便于输出。\n\n**源码已上传至本人的[GitHub仓库](https://github.com/eternidad33/MyTools-mini/tree/master/FileNameToMDLink)，欢迎访问**',24,'日常随笔','java,markdown',1,143,0,0,'2020-04-17 19:56:37','2020-04-17 19:56:37'),(3,'简易的图书管理系统','简易的图书管理系统 项目简介  推荐视频：JAVA+MySql 图书管理系统，技术:Swing+jdbc+mysql 用到的知识：Java，MySQL 工具：IDEA 源码已上传至码云','# 简易的图书管理系统\n\n## 项目简介\n\n推荐视频：[JAVA+MySql 图书管理系统，技术:Swing+jdbc+mysql](https://www.bilibili.com/video/BV1it41157ph?p=1)\n\n用到的知识：Java，MySQL\n\n工具：IDEA\n\n源码已上传至[码云](https://gitee.com/eternidad33/BookManager)\n\n[点击查看预览效果](https://gitee.com/eternidad33/BookManager)\n\n\n## 项目整体架构\n\n源码目录如下：\n\n```powershell\nPS E:\\IdeaProjects\\BookManager\\src> tree /f\n卷 软件 的文件夹 PATH 列表\n卷序列号为 54DD-69A2\nE:.\n├─dao\n│      BookDao.java\n│      BookTypeDao.java\n│      UserDao.java\n│\n├─entity\n│      Book.java\n│      Booktype.java\n│      User.java\n│\n├─images\n│      book.png\n│      susu.jpg\n│\n├─META-INF\n│      MANIFEST.MF\n│\n├─util\n│      DbUtil.java\n│      StringUtil.java\n│\n└─view\n        About.java\n        About.jfd\n        BookAddFrm.java\n        BookAddFrm.jfd\n        BookTypeAddFrm.java\n        BookTypeAddFrm.jfd\n        BookTypeManagerFrm.java\n        BookTypeManagerFrm.jfd\n        Login.form\n        Login.java\n        MainFrm.java\n        MainFrm.jfd\n```\n\n由此可见，本项目也是采用的MVC架构，`dao包`用于操作数据库，`entity包`包含本项目的实体类，`images包`是本项目用到的图片，`META-INF包`是生成Jar包时产生的文件夹，`util包`包含本项目用到的工具类，`view包`是本项目的视图层，用于设计窗口显示。\n\n项目中各类的依赖关系如下图\n\n![BookManager](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZXRlcm5pZGFkMzMvcGljYmVkL3Jhdy9tYXN0ZXIvaW1nL0Jvb2tNYW5hZ2VyLnBuZw?x-oss-process=image/format,png)\n\n## 具体实现\n\n### util包\n\n本项目的工具包，包含两个工具类\n\n`DbUtil.java`主要是设计了数据库的驱动，地址，用户名及密码，和控制数据库的连接与断开\n\n`StringUtil.java`只是用于判断字符串是否为空，只有空格也算为空\n\n---\n\n### entity包\n\n此包包含了数据库表的实体对象，可以自己写，也可以通过idea的`EasyCode`插件进行代码生成，但是后边要用到的必要的构造方法要自己写。\n\n大多数情况下都是简单类包含Getter和Setter方法，如下是`EasyCode`插件生成的代码\n\n```java\npublic class Booktype implements Serializable {\n    private static final long serialVersionUID = -43707012852599825L;\n\n    private Integer id;\n\n    private String booktypename;\n\n    @Override\n    public String toString() {\n        return this.booktypename;\n    }\n\n    private String booktypedesc;\n\n    public Booktype(String booktypename, String booktypedesc) {\n        this.booktypename = booktypename;\n        this.booktypedesc = booktypedesc;\n    }\n\n    public Booktype() {\n        super();\n    }\n\n    public Booktype(Integer id, String booktypename, String booktypedesc) {\n        this(booktypename, booktypedesc);\n        this.id = id;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getBooktypename() {\n        return booktypename;\n    }\n\n    public void setBooktypename(String booktypename) {\n        this.booktypename = booktypename;\n    }\n\n    public String getBooktypedesc() {\n        return booktypedesc;\n    }\n\n    public void setBooktypedesc(String booktypedesc) {\n        this.booktypedesc = booktypedesc;\n    }\n\n}\n```\n\n---\n\n### dao包\n\n进行数据库的访问\n\n类中的方法定义形式基本为`public 返回类型 方法名(Connection conn, 实体类 对象名) throws SQLException`\n\n例如用户登录的方法如下：\n\n```java\npublic User login(Connection connection, User user) throws SQLException {\n    User resultUser = null;\n    String sql = \"select * from table_user where userName=? and password=?\";\n    PreparedStatement psmt = connection.prepareStatement(sql);\n    psmt.setString(1, user.getUserName());\n    psmt.setString(2, user.getPassword());\n    ResultSet resultSet = psmt.executeQuery();\n    if (resultSet.next()) {\n        resultUser = new User();\n        resultUser.setId(resultSet.getInt(\"id\"));\n        resultUser.setUserName(resultSet.getString(\"userName\"));\n        resultUser.setPassword(resultSet.getString(\"password\"));\n    }\n    return resultUser;\n}\n```\n\n步骤总结：\n\n1. 其中SQL语句中的要查找的值要用`?`代替，方便后面设置\n\n   `String sql = \"select * from table_user where userName=? and password=?\";`\n\n2. 然后创建SQL语句的游标对象\n\n   `psmt`，`PreparedStatement psmt = connection.prepareStatement(sql);`\n\n3. 设置SQL语句中的变量值，**第几个`?`为几，索引就是几，没有0**\n\n   `psmt.setString(1, user.getUserName());`\n\n4. 执行查询语句，并返回`ResultSet`对象用于保存查询结果\n\n   `ResultSet resultSet = psmt.executeQuery();`\n\n5. 然后根据需求进行其他操作\n\n---\n\n`BookDao`类的设计如下，`dao`包下的其他类类似\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nL2Jvb2tEYW8ucG5n?x-oss-process=image/format,png)\n\n\n<font color=#0f0>添加图书</font>\n\n```java\npublic static int add(Connection connection, Book book) throws SQLException {\n    String sql = \"insert into book values(null,?,?,?,?,?,?)\";\n    PreparedStatement psmt = connection.prepareStatement(sql);\n    psmt.setString(1, book.getBookname());\n    psmt.setString(2, book.getAuthor());\n    psmt.setString(3, book.getSex());\n    psmt.setInt(4, book.getBooktypeid());\n    psmt.setString(5, book.getBookdesc());\n    psmt.setFloat(6, book.getPrice());\n    return psmt.executeUpdate();\n}\n```\n\n添加成功返回1，添加失败返回0\n\n---\n\n<font color=#f00>删除图书</font>\n\n```java\npublic static int delete(Connection conn, String id) throws SQLException {\n    String sql = \"delete from book where id=?\";\n    PreparedStatement psmt = conn.prepareStatement(sql);\n    psmt.setString(1, id);\n    return psmt.executeUpdate();\n}\n```\n\n删除成功返回1，删除失败返回0\n\n---\n\n<font color=#fc0>修改图书</font>\n\n```java\npublic static int update(Connection conn, Book book) throws SQLException {\n    String sql = \"update book set bookName=?,author=?,sex=?,price=?,bookTypeid=?,bookDesc=? where id=?\";\n    PreparedStatement psmt = conn.prepareStatement(sql);\n    psmt.setString(1, book.getBookname());\n    psmt.setString(2, book.getAuthor());\n    psmt.setString(3, book.getSex());\n    psmt.setFloat(4, book.getPrice());\n    psmt.setInt(5, book.getBooktypeid());\n    psmt.setString(6, book.getBookdesc());\n    psmt.setInt(7, book.getId());\n    return psmt.executeUpdate();\n}\n```\n\n修改成功返回1，修改失败返回0\n\n---\n\n<font color=#0cf>查询图书</font>\n\n```java\npublic static ResultSet list(Connection conn, Book book) throws SQLException {\n    StringBuffer sb = new StringBuffer(\"select * from book b,table_booktype bt where b.bookTypeId=bt.id\");\n    if (!StringUtil.isEmpty(book.getBookname())) {\n        sb.append(\" and b.bookName like \'%\" + book.getBookname() + \"%\'\");\n    }\n    if (!StringUtil.isEmpty(book.getAuthor())) {\n        sb.append(\" and b.author like \'%\" + book.getAuthor() + \"%\'\");\n    }\n    if (book.getBooktypeid() != null && book.getBooktypeid() != -1) {\n        sb.append(\" and b.bookTypeId=\" + book.getBooktypeid());\n    }\n    PreparedStatement psmt = conn.prepareStatement(sb.toString());\n    return psmt.executeQuery();\n}\n```\n\n返回查询结果\n\n---\n\n### view包\n\n视图层是利用的swing组件设计，但这个不是本项目的重点，因为Java的swing已经很少有人用了，可以直接使用idea中的`JFormDesigner`插件进行拖拉控件，使用时一定要注意将框架的布局类型设为`null Layout`，大小设为`Design size`\n\n我们只需设计按钮和表格的触发事件\n\n例如图书添加事件\n\n```java\nprivate void button1ActionPerformed(ActionEvent e) {\n    String bookName = this.booknameTXT.getText();\n    String author = this.bookAuthorTXT.getText();\n    String price = this.bookPriceTXT.getText();\n    String bookDesc = this.bookDescTXT.getText();\n    if (StringUtil.isEmpty(bookName)) {\n        JOptionPane.showMessageDialog(null, \"图书名称不能为空\");\n        return;\n    }\n    if (StringUtil.isEmpty(author)) {\n        JOptionPane.showMessageDialog(null, \"图书作者不能为空\");\n        return;\n    }\n    if (StringUtil.isEmpty(price)) {\n        JOptionPane.showMessageDialog(null, \"图书价格不能为空\");\n        return;\n    }\n    try {\n        float pricef = Float.parseFloat(price);\n    } catch (NumberFormatException numberFormatException) {\n        JOptionPane.showMessageDialog(null, \"图书价格应为数字\");\n        return;\n    }\n    String sex = \"\";\n    if (this.man.isSelected()) {\n        sex = \"男\";\n    } else {\n        sex = \"女\";\n    }\n    Booktype booktype = (Booktype) this.booktypecb.getSelectedItem();\n    assert booktype != null;\n    int booktypeId = booktype.getId();\n    Book book = new Book(bookName, author, sex, Float.parseFloat(price), booktypeId, bookDesc);\n    Connection conn = null;\n    try {\n        conn = dbUtil.getConnection();\n        int addNum = BookDao.add(conn, book);\n        if (addNum == 1) {\n            JOptionPane.showMessageDialog(null, \"添加成功\");\n            resetValue();\n        } else {\n            JOptionPane.showMessageDialog(null, \"添加失败\");\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n        JOptionPane.showMessageDialog(null, \"添加失败\");\n    } finally {\n        try {\n            conn.close();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n```\n\n设计思想：\n\n1. 判断必需的输入框是否为空，以及类型是否一致\n2. 获取各输入框的数据\n3. 根据数据实例化对象\n4. 调用`dao`包中对应的方法进行操作\n\n其他的删除，修改，查询的操作思想基本和添加的方法一样\n\n## 项目总结\n\n项目中使用到了Java的swing技术，但是现在已经很少有人会用Java去写软件界面了，Java不能像C#那样拖拉控件设计界面，但是可以在idea中安装`JFormDesigner`插件实现C#那样的效果。\n\n>  MVC全名是Model View  Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 \n\nMVC即围绕着数据库进行操作，本项目只是简单地实现了对数据库的增删改查，比较适合新手练习。',25,'开发','java,mysql',1,4021,0,0,'2020-04-18 19:55:23','2020-04-18 19:55:23'),(4,'用 IDEA 进行Junit单元测试','操作步骤  IDEA建一个Maven工程    添加Junit依赖    编写简单类    生成测试类    查看测试结果 添加Junit依赖','### 操作步骤\n\n1.  IDEA建一个Maven工程\n2. 添加Junit依赖\n3. 编写简单类\n4. 生成测试类\n5. 查看测试结果\n\n### 添加Junit依赖\n\n```xml\n<dependency>\n    <groupId>org.junit.jupiter</groupId>\n    <artifactId>junit-jupiter-api</artifactId>\n    <version>5.5.2</version>\n    <scope>test</scope>\n</dependency>\n```\n\n本例用Junit 5进行单元测试\n\n### 简单类\n\n```java\npublic class Student {\n\n    /**\n     * id : 20171004024\n     * name : Vigilr\n     * Java : 99.0\n     * Python : 98.0\n     * JavaScript : 97.0\n     */\n\n    private long id;\n    private String name;\n    private double Java;\n    private double Python;\n    private double JavaScript;\n\n    public Student() {\n        this.id=123456789;\n        this.name=\"张三\";\n        this.Java=60.0;\n        this.Python=60.1;\n        this.JavaScript=59.9;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    @Override\n    public String toString() {\n        final StringBuffer sb = new StringBuffer(\"Student{\");\n        sb.append(\"id=\").append(id);\n        sb.append(\", name=\'\").append(name).append(\'\\\'\');\n        sb.append(\", Java=\").append(Java);\n        sb.append(\", Python=\").append(Python);\n        sb.append(\", JavaScript=\").append(JavaScript);\n        sb.append(\'}\');\n        return sb.toString();\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public double getJava() {\n        return Java;\n    }\n\n    public void setJava(double Java) {\n        this.Java = Java;\n    }\n\n    public double getPython() {\n        return Python;\n    }\n\n    public void setPython(double Python) {\n        this.Python = Python;\n    }\n\n    public double getJavaScript() {\n        return JavaScript;\n    }\n\n    public void setJavaScript(double JavaScript) {\n        this.JavaScript = JavaScript;\n    }\n\n    /**\n    * 计算学生成绩总分\n    *\n    * @return double\n    * @since 2020/4/22        \n    */ \n    public double sum() {\n        return this.Java + this.Python + this.JavaScript;\n    }\n}\n\n```\n\n> 本类通过`GsonFormat`直接生成setter,getter方法，然后编写构造方法和计算总成绩方法。\n\n### 测试类\n\n快捷键<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>T</kbd>创建测试类\n\n```java\nclass StudentTest {\n\n    Student stu = null;\n\n    @BeforeEach\n    void setUp() {\n        stu = new Student();\n        System.out.println(\"开始单元测试\");\n    }\n\n    @AfterEach\n    void tearDown() {\n        System.out.println(\"结束单元测试\");\n    }\n\n    @Test\n    void getId() {\n        System.out.println(\"getId()：\" + stu.getId() + \"，测试成功\");\n    }\n\n    @Test\n    void setId() {\n        stu.setId(654321);\n        assertEquals( 654321,stu.getId(),\"setId()方法异常\");\n        System.out.println(\"setId()测试成功\");\n    }\n\n    @Test\n    void getName() {\n        System.out.println(\"getName()：\" + stu.getName() + \"，测试成功\");\n    }\n\n    @Test\n    void setName() {\n        stu.setName(\"李四\");\n        assertEquals(stu.getName(), \"李四\");\n        System.out.println(\"setName()测试成功\");\n    }\n\n    @Test\n    void getJava() {\n        System.out.println(\"Java成绩为\"+stu.getJava()+\"，测试成功\");\n    }\n\n    @Test\n    void setJava() {\n        stu.setJava(99.9);\n        assertEquals(99.9,stu.getJava(),\"setJava()方法异常\");\n        System.out.println(\"setJava()测试成功\");\n    }\n\n    @Test\n    void sum() {\n        assertEquals( 180,stu.sum(),\"sum()方法异常\");\n        System.out.println(stu);\n        System.out.println(\"张三总分为180，sum()测试成功\");\n    }\n\n}\n```\n\n### 测试结果\n\n测试成功的结果：\n\n![测试成功](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZXRlcm5pZGFkMzMvcGljYmVkL3Jhdy9tYXN0ZXIvaW1nL3N0dWRlbnR0ZXN0cy5wbmc?x-oss-process=image/format,png)\n\n测试失败的结果：\n\n![测试失败](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZXRlcm5pZGFkMzMvcGljYmVkL3Jhdy9tYXN0ZXIvaW1nL3N0dWRlbnR0ZXN0Zi5wbmc?x-oss-process=image/format,png)\n\n### Junit 5总结\n\n**注解**\n\n`@BeforeAll `只执行一次，在所有测试和 @BeforeEach 注解方法之前。 \n\n`@BeforeEach`在每个单元测试执行之前执行。 \n\n`@Test`进行单元测试\n\n`@AfterEach`在每个单元测试执行之后执行。 \n\n`@AfterAll`只执行一次，最后执行\n\n**断言**\n\n基本用法：`assertEquals(预期结果,实际测试结果,报错信息)`',24,'日常随笔','idea',1,465,0,0,'2020-04-23 19:52:31','2020-04-23 19:52:31'),(5,'Visio形状栏消失后显示','今天再用Visio绘制状态图时一不小心把左侧的形状栏隐藏了，之后在网上找了半天才找到解决方案，（主要是自己不太会总结关键词）参考链接microsoft visio 左边的形状如何打开','> 今天再用Visio绘制状态图时一不小心把左侧的形状栏隐藏了，之后在网上找了半天才找到解决方案，（主要是自己不太会总结关键词）参考链接[microsoft visio 左边的形状如何打开](https://zhidao.baidu.com/question/106430461.html)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200518200555359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTA3ODAy,size_16,color_FFFFFF,t_70)解决方案：\n1. 选择视图按钮\n2. 单击任务窗格，选择形状\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200518201059594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTA3ODAy,size_16,color_FFFFFF,t_70)\n4. 显示效果![在这里插入图片描述](https://img-blog.csdnimg.cn/20200518201407379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTA3ODAy,size_16,color_FFFFFF,t_70)',24,'日常随笔','visio',1,1014,0,0,'2020-05-18 20:14:31','2020-05-18 20:14:31'),(6,'selenium+sqlalchemy 爬取京东商品信息并存入MySQL','导入必要的包 # 浏览器驱动 from selenium import webdriver# 模拟键盘按键操作\r\nfrom selenium.webdriver.common.keys import Keys','## 导入必要的包\n\n\n```python\n# 浏览器驱动\nfrom selenium import webdriver\n# 模拟键盘按键操作\nfrom selenium.webdriver.common.keys import Keys\n# 用于设置休眠和获取时间\nimport time\n# 数据库相关\nfrom sqlalchemy import create_engine, Integer,String,Float\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy import Column\n```\n\n## 自动打开火狐浏览器\n\n用火狐浏览器需将驱动设置为`webdriver.Firefox()`，火狐浏览器驱动还需在[GitHub](https://github.com/mozilla/geckodriver/releases)下载geckodriver，并解压到Anaconda3\\Scripts目录下(也可单独添加到环境变量中)，用于启动浏览器\n\n用谷歌浏览器同理，将驱动设置为`webdriver.Chrome()`需下载，可以从[chromium站点](https://sites.google.com/a/chromium.org/chromedriver/downloads)下载，同时添加到环境变量中\n\n> 驱动版本一定要和浏览器版本相匹配\n\n\n```python\nkeyword=\'电脑\'\ndriver=webdriver.Firefox()\n# driver=webdriver.Chrome()\ndriver.get(\'https://www.jd.com\')\nkey=driver.find_element_by_id(\'key\')\nkey.send_keys(keyword)\nkey.send_keys(Keys.RETURN)\n```\n\n## 设置排序方式\n\n可以设置按销量排序，也可以不设置，直接综合排序，按销量排序时，应该等到出现限量按钮才可以点击，可通过设置休眠时间解决。\n\n\n```python\n# 按销量排序\n# 设置休眠时间\ntime.sleep(3)\nsort_btn=driver.find_element_by_xpath(\'.//div[@class=\"f-sort\"]/a[2]\')\nsort_btn.click()\n```\n\n## 获取商品列表的长度\n\n滑动到翻页位置，用于模拟点击下一页\n\n\n```python\ngoods_list=driver.find_element_by_id(\'J_goodsList\')\nh=(goods_list.rect[\'y\']+goods_list.rect[\'height\'])\ntime.sleep(1)\ndriver.execute_script(\'window.scrollTo(0,%s)\'%h)\n```\n\n## 获取所有的商品标签\n\n\n```python\nproducts=driver.find_elements_by_class_name(\'gl-item\')\nlen(products)\n```\n\n\n    30\n\n## 爬取第一件商品\n\n可通过id，标签，CSS，类选择器获取相关信息\n\n\n```python\ntime.sleep(3)\n# 获取商品sku\np=products[0]\nsku=p.get_attribute(\'data-sku\')\nsku\n```\n\n\n    \'100012950122\'\n\n京东商品的连接可通过sku获取，例如sku为\'100008348538\'，该商品的链接为https://item.jd.com/100008348538.html\n\n格式为`https://item.jd.com/`+`sku`+`.html`\n\n\n```python\n# 爬取价格\nprice=p.find_element_by_class_name(\'p-price\').text\nprice\n```\n\n\n    \'￥4489.00\'\n\n\n```python\n# 爬取名称\nname=p.find_element_by_css_selector(\'div.p-name\').text\nname\n```\n\n\n    \'联想(Lenovo)天逸510S 英特尔酷睿i5 个人商务台式机电脑主机(i5-9400 16G 1T+256G SSD WiFi Win10)23英寸\'\n\n\n```python\n# 爬取评价数量\ncommentcount=p.find_element_by_id(\'J_comment_%s\'%sku).text\ncommentcount\n```\n\n\n    \'2700+\'\n\n\n```python\n# 爬取店铺\nshop=p.find_element_by_class_name(\'p-shop\').text\nshop\n```\n\n\n    \'联想京东自营旗舰店\'\n\n\n```python\n# 爬取封面图片\nu=p.find_element_by_tag_name(\'img\').get_attribute(\'src\')\nu\n```\n\n\n    \'https://img12.360buyimg.com/n7/jfs/t1/128291/24/552/56550/5eb65126E0f5ebeb1/fc0e83834d771cf8.jpg\'\n\n\n```python\n# 保存图片\nimport urllib\nurllib.request.urlretrieve(u,\'img/\'+sku+\'.jpg\')\n```\n\n\n    (\'img/100012950122.jpg\', <http.client.HTTPMessage at 0x188aa79f5c8>)\n\n## 将数据存储到数据库\n\n\n```python\n# 创建数据库的连接\nengine = create_engine(\"mysql+pymysql://root:123456@127.0.0.1:3308/xymall?charset=utf8\")\n# 操作数据库，创建一个session\nSession = sessionmaker(bind=engine)\n# 声明一个基类\nBase = declarative_base()\n```\n\n\n```python\n# 定义表结构\nclass jdPCTest(Base):\n    __tablename__=\'jdPCTest\'\n    id = Column(Integer,primary_key=True,autoincrement=True)\n    sku = Column(String(length=50),nullable=True)\n    name = Column(String(length=500),nullable=False)\n    price = Column(String(length=20),nullable=False)\n    comment=Column(String(length=20),nullable=False)\n    shop=Column(String(length=20),nullable=False)\n    date=Column(String(length=20),nullable=False)\n```\n\n\n```python\n# 创建数据表\njdPCTest.metadata.create_all(engine)\n```\n\n```python\nmysqlSession=Session()\n# 日期\ndate = time.strftime(\"%Y-%m-%d\",time.localtime())\n# 存储的数据结构\ndata = jdPCTest(\n    sku=sku,\n    name=name,\n    price=price,\n    comment=commentcount,\n    shop=shop,\n    date=date\n)\nmysqlSession.add(data)\nmysqlSession.commit()\n```\n\n> 本文件为 jupyter Notebook导出文件，源文件可从[码云](https://gitee.com/xy221/mall/tree/master/crawlData)下载',25,'开发','mysql,python,selenium',1,394,0,0,'2020-06-04 19:54:21','2020-06-04 19:54:21'),(7,'阿里云宝塔面板配置及部署Java项目','阿里云宝塔面板配置及部署Java项目 购买服务器 直接购买就可以了 有活动时购买比较便宜，我记得曾经有个活动是70一年的服务器 现在购买可以91.8一年 ','# 阿里云宝塔面板配置及部署Java项目\n\n## 购买服务器\n\n直接购买就可以了\n\n有活动时购买比较便宜，我记得曾经有个活动是70一年的服务器\n\n现在购买可以91.8一年\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nL2FsaXl1bjkxLjgucG5n?x-oss-process=image/format,png#pic_center)\n\n学生购买是9.50一个月（参与[云翼计划](https://promotion.aliyun.com/ntms/act/campus2018.html)然后学生认证即可）\n\n> 我是单买的一个月的，因为不经常用，想用的时候就买一个月的\n\n## 安装镜像\n\n从镜像市场选择宝塔控制面板安装\n\n![宝塔](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nLyVFNSVBRSU5RCVFNSVBMSU5NC5wbmc?x-oss-process=image/format,png#pic_center)\n\n> [宝塔Linux面板（LAMP/LNMP/Tomcat/Node.js）](https://market.aliyun.com/products/53690006/cmjj015022.html)\n>\n> 功能强大且终身免费的Linux服务器管理软件，一键部署：LAMP/LNMP/Tomcat/Node.js、网站、数据库、FTP、SSL，通过Web端轻松管理服务器。\n\n镜像安装完要配置安全组打开相应端口\n\n![安全组](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nLyVFNSVBRSU4OSVFNSU4NSVBOCVFNyVCQiU4NC5wbmc?x-oss-process=image/format,png#pic_center)\n\n## 面板配置\n\n`bt`命令进行相关的操作\n\n![bt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nL2J0LnBuZw?x-oss-process=image/format,png#pic_center)\n\n可以更改掉默认的用户名和密码\n\n浏览器访问`公网ip:8888`进行环境的安装\n\n![面板首页](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nLyVFOSU5RCVBMiVFNiU5RCVCRiVFOSVBNiU5NiVFOSVBMSVCNS5wbmc?x-oss-process=image/format,png#pic_center)\n\n可以选择LNMP安装，大约5~6分钟安装完成\n\n![已安装软件](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nLyVFNSVCNyVCMiVFNSVBRSU4OSVFOCVBMyU4NSVFOCVCRCVBRiVFNCVCQiVCNi5wbmc?x-oss-process=image/format,png#pic_center)\n\n配置mysql数据库相应的端口，默认3306，可以改为其他端口\n\n安装完成后可以数据库的root密码\n\n## 安装Tomcat\n\n从左侧的软件商店安装Tomcat（不用单独安装Java，面板自动安装Java）\n\n安装完tomcat后要在面板中放行8080端口，前边的安全组也要放行8080端口\n\n![面板防火墙](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nLyVFOSU5RCVBMiVFNiU5RCVCRiVFOSU5OCVCMiVFNyU4MSVBQiVFNSVBMiU5OS5wbmc?x-oss-process=image/format,png#pic_center)\n\n浏览器成功访问`公网ip:8080`，即为成功安装\n\n![tomcat9](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nL3RvbWNhdDkucG5n?x-oss-process=image/format,png#pic_center)\n\n## 部署项目\n\n本文部署的是[GitHub](https://github.com/MccreeFei/EasyChat)上的 一个基于SSM+Websocket的实时在线聊天室项目 \n\n配置数据库信息并生成war包\n\n![生成WAR包](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nLyVFNyU5NCU5RiVFNiU4OCU5MFdBUiVFNSU4QyU4NS5wbmc?x-oss-process=image/format,png#pic_center)\n\n成功生成war包后的效果如下：\n\n![war生成成功](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nL3dhciVFNyU5NCU5RiVFNiU4OCU5MCVFNiU4OCU5MCVFNSU4QSU5Ri5wbmc?x-oss-process=image/format,png#pic_center)\n\n在服务器的mysql运行本项目中的sql文件\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200616133230949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTA3ODAy,size_16,color_FFFFFF,t_70#pic_center)\n\n将生成的war文件上传到`/www/server/tomcat/webapps`目录下，tomcat会自动解压\n\n![wabapps](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nL3dhYmFwcHMucG5n?x-oss-process=image/format,png#pic_center)\n\n> 上传文件方法有很多，可以通过命令行，也可以用工具，我知道的工具如下：\n>\n> 1. xshell及xftp\n> 2. IDEA的阿里云部署插件(Alibaba Cloud Toolkit)\n> 3. 通过宝塔面板上传\n\n浏览器访问[公网IP:8080/网站应用名](http://112.124.30.121:8080/easy-chat/)，出现下面的界面即为成功部署\n\n![easychat部署](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nL2Vhc3ljaGF0JUU5JTgzJUE4JUU3JUJEJUIyLnBuZw?x-oss-process=image/format,png#pic_center)\n\n> 文章如果有什么错误的地方，欢迎大家评论留言',24,'日常随笔','java',1,3091,0,0,'2020-06-16 10:05:38','2020-06-16 10:05:38'),(8,'本地添加多个ssh公钥','在一台电脑上生成多个公钥格式ssh-keygen -t rsa -C 邮箱 公钥名 例如：ssh-keygen -t rsa -C \"456@qq.com\" -f ~/.ssh/id_github_vigilr ssh-keygen -t rsa -C \"123@qq.com\" -f ~/.ssh/id_gitee_vigilr','在一台电脑上生成多个公钥格式`ssh-keygen -t rsa -C 邮箱 公钥名`\n\n例如：\n```bash\nssh-keygen -t rsa -C \"456@qq.com\" -f ~/.ssh/id_github_vigilr\nssh-keygen -t rsa -C \"123@qq.com\" -f ~/.ssh/id_gitee_vigilr\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200616215715910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTA3ODAy,size_16,color_FFFFFF,t_70)\n> ssh路径一般是在.ssh文件夹里的\n\n配置.ssh文件夹下的config文件（如果没有就新建一个，没有后缀）\n\nconfig文件内容如下：\n```bash\n# 配置github.com\n\nHost github.com               \n\n    HostName github.com\n\n    IdentityFile C:\\\\Users\\\\Administrator\\\\.ssh\\\\id_github_vigilr\n\n# 配置gitee\n\nHost gitee.com\n    \n    HostName gitee.com\n    \n    IdentityFile C:\\\\Users\\\\Administrator\\\\.ssh\\\\id_gitee_vigilr\n    \n```\n\n最后把对应的公钥（后缀为.pub文件的内容）放在GitHub或者gitee即可',24,'日常随笔','ssh',1,667,0,0,'2020-06-16 22:09:45','2020-06-16 22:09:45'),(9,'TCP与UDP编程','Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。客户端 操作步骤    创建socket    建立连接    接收服务端数据    发送数据    断开连接','> Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。\n## 客户端\n**操作步骤**\n1. 创建socket\n2. 建立连接\n3. 接收服务端数据\n4. 发送数据\n5. 断开连接\n```python\n# 客户端代码\nimport socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n# 建立连接:\ns.connect((\'127.0.0.1\', 9999))\n# 接收欢迎消息:\nprint(s.recv(1024).decode(\'utf-8\'))\nfor data in [b\'Michael\', b\'Tracy\', b\'Sarah\']:\n    # 发送数据:\n    s.send(data)\n    print(s.recv(1024).decode(\'utf-8\'))\ns.send(b\'exit\')\ns.close()\n```\n## 服务端\n**操作步骤**\n1. 创建socket\n2. 绑定监听端口\n3. 多线程接收客户端连接\n4. 数据接收与发送\n\n```python\nimport socket,threading,time\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# 监听端口:\ns.bind((\'127.0.0.1\', 9999))\n\ns.listen(5)\nprint(\'Waiting for connection...\')\n\n# 每个连接都必须创建新线程（或进程）来处理，\n# 否则，单线程在处理连接的过程中，无法接受其他客户端的连接：\ndef tcplink(sock, addr):\n    print(\'Accept new connection from %s:%s...\' % addr)\n    sock.send(b\'Welcome!\')\n    while True:\n        data = sock.recv(1024)\n        time.sleep(1)\n        if not data or data.decode(\'utf-8\') == \'exit\':\n            break\n        sock.send((\'Hello, %s!\' % data.decode(\'utf-8\')).encode(\'utf-8\'))\n    sock.close()\n    print(\'Connection from %s:%s closed.\' % addr)\n    \nwhile True:\n    # 接受一个新连接:\n    sock, addr = s.accept()\n    # 创建新线程来处理TCP连接:\n    t = threading.Thread(target=tcplink, args=(sock, addr))\n    t.start()\n```\n运行截图\n\n服务端：\n![服务端](https://img-blog.csdnimg.cn/20200617192107243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTA3ODAy,size_16,color_FFFFFF,t_70)\n客户端：\n![客户端](https://img-blog.csdnimg.cn/20200617192107226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTA3ODAy,size_16,color_FFFFFF,t_70)\n## UDP\nTCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。\n\n使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。\n\n虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。\n\n我们来看看如何通过UDP协议传输数据。和TCP类似，使用UDP的通信双方也分为客户端和服务器。服务器首先需要绑定端口：\n```python\ns = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n# 绑定端口:\ns.bind((\'127.0.0.1\', 9999))\n```\n\n创建Socket时，`SOCK_DGRAM`指定了这个Socket的类型是UDP。绑定端口和TCP一样，但是不需要调用`listen()`方法，而是直接接收来自任何客户端的数据：\n```python\nprint(\'Bind UDP on 9999...\')\nwhile True:\n    # 接收数据:\n    data, addr = s.recvfrom(1024)\n    print(\'Received from %s:%s.\' % addr)\n    s.sendto(b\'Hello, %s!\' % data, addr)\n ```\n\n`recvfrom()`方法返回数据和客户端的地址与端口，这样，服务器收到数据后，直接调用`sendto()`就可以把数据用UDP发给客户端。\n\n\n客户端使用UDP时，首先仍然创建基于UDP的Socket，然后，不需要调用`connect()`，直接通过`sendto()`给服务器发数据：\n```python\ns = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nfor data in [b\'Michael\', b\'Tracy\', b\'Sarah\']:\n    # 发送数据:\n    s.sendto(data, (\'127.0.0.1\', 9999))\n    # 接收数据:\n    print(s.recv(1024).decode(\'utf-8\'))\ns.close()\n```\n从服务器接收数据仍然调用`recv()`方法。',25,'开发','python',1,481,0,0,'2020-06-17 20:29:28','2020-06-17 20:29:28'),(10,'自定义自己的GitHub主页','虽然代码不怎么写，但是逼格不能丢 直接看演示效果','> 虽然代码不怎么写，但是逼格不能丢\n\n直接看演示效果\n\n![演示效果](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODc4MDIyNi1mMWQ1Y2Q1NjJmNmVjMTExLnBuZw?x-oss-process=image/format,png)\n\n创建以用户名为名称的仓库\n自定义自己的 README 文件即可在自己的 github 显示了\n\n我这个上边显示的编码时长，是添加了一个 action 每天更新自己的编码时长\n具体设计步骤可参考 github 上的[athul/waka-readme](https://github.com/athul/waka-readme)项目\n\n总结一下简要的步骤\n\n1. 注册 wakatime 账号\n2. 在自己常用的 IDE 上下载 wakatime 插件，配置上自己的 API key\n3. 将自己的 API key 存到自己 GitHub 仓库的 secrets\n4. 在 README 文件上加上\n\n```markdown\n  <!--START_SECTION:waka-->\n  <!--END_SECTION:waka-->\n```\n\n5. 配置 GitHub 仓库的 Action，这样就能每天自动运行了\n\n欢迎大家访问我的[github](https://github.com/eternidad33)',24,'日常随笔','github',1,810,0,0,'2020-07-20 15:38:30','2020-07-20 15:38:30'),(11,'历年 CCF CSP 认证部分题解','源码已上传至码云和GitHub\r\n\r\n2021/1/8 更新\r\n\r\n由于我在 CSDN 关于 CSP 题解的文章杂乱无章，今天闲来无事，于是就把我的博客文章重新整理了一下，题解详情已通过docsify部署到了码云和GitHub\r\nJava 题解 试题编号	试题名称	最高得分 202006-1	线性分类器	100 201912-1	报数	100 201909-1	小明种苹果	100 201903-1	小中大	100 201812-1	小明上学	100 201809-1	卖菜	100','> 源码已上传至[码云](https://gitee.com/eternidad33/csp)和[GitHub](https://github.com/eternidad33/csp)\n\n**2021/1/8 更新**\n\n由于我在 CSDN 关于 CSP 题解的文章杂乱无章，今天闲来无事，于是就把我的博客文章重新整理了一下，题解详情已通过`docsify`部署到了[码云](https://eternidad33.gitee.io/csp/)和[GitHub](https://eternidad33.gitee.io/csp/#/)\n\n**Java 题解**\n\n| 试题编号 |                                  试题名称                                   | 最高得分 |\n| :------: | :-------------------------------------------------------------------------: | :------: |\n| 202006-1 |       [线性分类器](https://eternidad33.gitee.io/csp/#/csp/线性分类器)       |   100    |\n| 201912-1 |             [报数](https://eternidad33.gitee.io/csp/#/csp/报数)             |   100    |\n| 201909-1 |       [小明种苹果](https://eternidad33.gitee.io/csp/#/csp/小明种苹果)       |   100    |\n| 201903-1 |           [小中大](https://eternidad33.gitee.io/csp/#/csp/小中大)           |   100    |\n| 201812-1 |         [小明上学](https://eternidad33.gitee.io/csp/#/csp/小明上学)         |   100    |\n| 201809-1 |             [卖菜](https://eternidad33.gitee.io/csp/#/csp/卖菜)             |   100    |\n| 201803-1 |           [跳一跳](https://eternidad33.gitee.io/csp/#/csp/跳一跳)           |   100    |\n| 201712-1 |         [最小差值](https://eternidad33.gitee.io/csp/#/csp/最小差值)         |   100    |\n| 201709-1 |           [打酱油](https://eternidad33.gitee.io/csp/#/csp/打酱油)           |   100    |\n| 201703-1 |           [分蛋糕](https://eternidad33.gitee.io/csp/#/csp/分蛋糕)           |   100    |\n| 201612-1 |           [中间数](https://eternidad33.gitee.io/csp/#/csp/中间数)           |   100    |\n| 201609-1 |         [最大波动](https://eternidad33.gitee.io/csp/#/csp/最大波动)         |   100    |\n| 201604-1 |         [折点计数](https://eternidad33.gitee.io/csp/#/csp/折点计数)         |   100    |\n| 201512-1 |         [数位之和](https://eternidad33.gitee.io/csp/#/csp/数位之和)         |   100    |\n| 201509-1 |         [数列分段](https://eternidad33.gitee.io/csp/#/csp/数列分段)         |   100    |\n| 201503-1 |         [图像旋转](https://eternidad33.gitee.io/csp/#/csp/图像旋转)         |   100    |\n| 201412-1 |         [门禁系统](https://eternidad33.gitee.io/csp/#/csp/门禁系统)         |   100    |\n| 201409-1 |         [相邻数对](https://eternidad33.gitee.io/csp/#/csp/相邻数对)         |   100    |\n| 201403-1 |           [相反数](https://eternidad33.gitee.io/csp/#/csp/相反数)           |   100    |\n| 201312-1 | [出现次数最多的数](https://eternidad33.gitee.io/csp/#/csp/出现次数最多的数) |   100    |\n\n\n**Python 题解**\n\n- [第 1 题](https://eternidad33.gitee.io/csp/#/csp/py1)\n- [第 2 题](https://eternidad33.gitee.io/csp/#/csp/py2)\n- [第 3 题](https://eternidad33.gitee.io/csp/#/csp/py3)',24,'日常随笔','java,python',1,857,0,0,'2020-08-07 09:20:24','2020-08-07 09:20:24'),(12,'牛客高赞评论整理','      本文总结在牛客刷题过程中，遇到的错题及相关的高赞评论解析。  数据结构  对n个记录的文件进行快速排序，所需要的辅助存储空间大致为','> 本文总结在牛客刷题过程中，遇到的错题及相关的高赞评论解析。\n\n## 数据结构\n**[对n个记录的文件进行快速排序，所需要的辅助存储空间大致为](https://www.nowcoder.com/questionTerminal/d4d3b9e4c5974aae869ce1fd61fd8c8a)**\n\n```\n正确答案: C   你的答案: C\n\nA、O（1）\nB、O（n）\nC、O（1og2n）\nD、O（n2）\n```\n\n辅助存储空间 = 时间复杂度 \n额外存储空间 = 空间复杂度\n\n快速排序对待排序序列得划分大约是log<sub>2</sub>n次，因为快速排序是通过递归算法来实现的，递归深度大约是log<sub>2</sub>n，所以所需得辅助空间为log<sub>2</sub>n\n\n---\n\n**[基于比较的排序算法是（ ）](https://www.nowcoder.com/questionTerminal/5a7581e365d94db0966ab808ce304928)**\n\n```\n正确答案: B D  你的答案: B D\n\nA、基数排序\nB、冒泡排序\nC、桶排序\nD、希尔排序\n```\n\n1、基于比较的排序算法有：（1）直接插入排序；（2）冒泡排序；（3）简单选择排序；（4）希尔排序；（5）快速排序；（6）堆排序；（7）归并排序。 \n\n2、基数排序、桶排序都属于分配式排序，且都是稳定排序算法。 \n\n---\n\n**[待排序元素规模较小时，宜选取哪种排序算法效率最高（   ）](https://www.nowcoder.com/questionTerminal/a95f7e2431174ed69422df4b5354113a)**\n\n```\n正确答案: C  你的答案: C\n\nA、堆排序\nB、归并排序\nC、冒泡排序\nD、希尔排序\n```\n笔记：递归时间可能长于比较时间\n\n---\n\n**[下面有关P问题，NP问题和NPC问题，说法错误的是](https://www.nowcoder.com/questionTerminal/8b52ba2d570545fdae8ee1f7cb264ec1)**\n\n```\n正确答案: D  你的答案: D\n\nA、如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题\nB、NP问题是指可以在多项式的时间里验证一个解的问题\nC、所有的P类问题都是NP问题\nD、NPC问题不一定是个NP问题，只要保证所有的NP问题都可以约化到它即可\n```\n\n\nP:   能在多项式时间内解决的问题\n\nNP: 不能在多项式时间内解决或不确定能不能在多项式时间内解决，但能在多项式时间验证的问题\n\nNPC: NP完全问题，所有NP问题在多项式时间内都能约化(Reducibility)到它的NP问题，即解决了此NPC问题，所有NP问题也都得到解决。\n\nNP hard:NP难问题， 所有NP问题在多项式时间内都能约化(Reducibility)到它的问题(不一定是NP问题)。\n\n---\n\n**[int main(){fork()||fork();}共创建几个进程：](https://www.nowcoder.com/questionTerminal/b8321978323c43c694a561d151e69fd0)**\n\n```\n正确答案: C   你的答案: C\n\nA、1\nB、2\nC、3\nD、4\nE、5\nF、6\n```\n\n`fork()`给子进程返回一个零值，而给父进程返回一个非零值； \n\n在main这个主进程中，首先执行  `fork()|| fork()`,  左边的fork()返回一个非零值，根据`||`的短路原则，前面的表达式为真时，后面的表达式不执行，故包含main的这个主进程创建了一个子进程，由于子进程会复制父进程，而且子进程会根据其返回值继续执行，就是说，在子进程中，`fork()||fork()`这条语句左边表达式的返回值是0,  所以`||`右边的表达式要执行，这时在子进程中又创建了一个进程，即main进程->子进程->子进程，一共创建了3个进程。 \n\n## 操作系统\n\n**[以下哪个命令用于查看tar（backup.tar）文件的内容而不提取它?（）](https://www.nowcoder.com/questionTerminal/4e632ee9fb3c45e2bad336236b5ef3a9)** \n\n```\n正确答案: B  你的答案: B\n\nA、tar -xvf backup.tar\nB、tar -tvf backup.tar\nC、tar -svf backup.tar\nD、none of these\n```\n\n**[linux中tar命令用法](https://www.cnblogs.com/newcaoguo/p/5896975.html)**\n\n1. *.tar 用 tar –xvf 解压 \n2. *.gz 用 gzip -d或者gunzip 解压     \n3. \\*.tar.gz和*.tgz 用 tar –xzf 解压     \n4. *.bz2 用 bzip2 -d或者用bunzip2 解压     \n5. *.tar.bz2用tar –xjf 解压     \n6. *.Z 用 uncompress 解压     \n7. *.tar.Z 用tar –xZf 解压     \n8. *.rar 用 unrar e解压     \n9. *.zip 用 unzip 解压\n\n---\n\n**[下列说法中，错误的是（）](https://www.nowcoder.com/questionTerminal/35ad5448a793489d90d197823c879195)** \n\n```\n正确答案: D  你的答案: D\n\nA、指令就是命令，它用来规定CPU执行什么操作\nB、指令是构成程序的基本单位，程序是由一连串指令组成的\nC、指令采用二进位表示\nD、指令一般由4个部分组成\n```\n\n> 指令一般由两部分组成：\n> 操作码：该指令完成操作的类型或性质 \n> 地址码：操作对象的地址 \n\n---\n\n**[有作业控制块JCB连成一串而形成的排队队列称为（）。](https://www.nowcoder.com/questionTerminal/489c515483794a789dc303aee0e6ebc8)**\n\n```\n正确答案: D  你的答案: D\n\nA、挂起队列\nB、阻塞队列\nC、就绪队列\nD、后备队列\n```\n\n高级调度：从后备作业队列（作业控制块）中将作业调入进就绪进程队列，所以作业控制块中存放的是后背作业队列。 \n\n中级调度：是为了提高内存的使用率，将一些暂时不能运行的进程从内存移动到外存上去，即内存外出不断交换，所以中级调度会涉及到虚拟存储器。暂时不能运行的进程，由就绪挂起队列，阻塞挂起队列。而阻塞队列里的进程会由于等待时间过长自动调入到阻塞挂起队列里面去。 \n\n低级调度（短程调度）分两类，非抢占式调度和抢占式调度，从就绪进程队列中选取合适进程送到CPU上运行。 \n\n---\n\n**[死锁的预防方法中，不太可能的一种方法是（ ）。](https://www.nowcoder.com/questionTerminal/93cf7ebf8e074a7c9f0a36254391afd4)**\n\n```\n正确答案: A  你的答案: A\n\nA、摒弃互斥条件\nB、摒弃请求和保持条件\nC、摒弃不剥夺条件\nD、摒弃环路等待条件\n```\n\n1. 互斥条件：一个资源每次只能被一个进程使用。**不可破坏**  \n\n2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。**一次性分配：要么全给，要么啥也不给。**\n\n3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 **设置优先级，高优先级可要求低优先级让出资源。**\n\n4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。**对资源进行编号，按照编号顺序申请访问**\n\n---\n\n**[下列性质中，哪一个不是分时系统的特征（）。](https://www.nowcoder.com/questionTerminal/19cba64765944273a5d8938e165e26b0)**\n\n```\n正确答案: C  你的答案: C\n\nA、交互性\nB、多路性\nC、成批性\nD、独占性\n```\n\n分时系统具有多路性、交互性、独占性和及时性的特征。\n\n多路性指，伺时有多个用户使用一台计算机，宏观上看是多个人同时使用一个CPU，微观上是多个人在不同时刻轮流使用CPU。\n\n交互性是指，用户根据系统响应结果进一步提出新请求(用户直接干预每一步)。\n\n独占性是指，用户感觉不到计算机为其他人服务，就像整个系统为他所独占。\n\n及时性指，系统对用户提出的请求及时响应。  \n\n**实时操作系统**基本特征：及时性，可靠性 \n\n\n---\n\n**[关于总线的说法中正确的是(  )](https://www.nowcoder.com/questionTerminal/15f2927d582a48c4b1677d7b9e0342ea)**\n\n```\n正确答案: A  你的答案: A\n\nA、总线是用于连接CPU、内存、外存和各种I/O设备并在它们之间传输信息的一组共享的传输线及其控制电路\nB、I/O总线是用于连接CPU和内存的总线\nC、CPU总线是连接内存和I/O设备（包括外存）的总线\nD、计算机总线中只包含CPU总线\n```\n\n**总线按功能和规范可分为五大类型:**\n\n- 数据总线(Data Bus):在CPU与RAM之间来回传送需要处理或是需要储存的数据。  \n- 地址总线(Address Bus):用来指定在RAM(Random Access Memory)之中储存的数据的地址。  \n- 控制总线(Control Bus):将微处理器控制单元(Control Unit)的信号，传送到周边设备，一般常见的为USB Bus和1394 Bus。  \n- 扩展总线(Expansion Bus):可连接扩展槽和电脑。  \n- 局部总线(Local Bus):取代更高速数据传输的扩展总线。\n\n## 数据库\n\n**[在mysql中，以下哪种方式可以开启一个事务？](https://www.nowcoder.com/questionTerminal/018e6413d33f403384f0a4aa980f6bf5)**\n\n```\n正确答案: A C  你的答案: A C\n\nA、START TRANSACTION\nB、START\nC、BEGIN\nD、BEIGN TRANSACTION\n```\n\n- BEGIN或START TRANSACTION；显示地开启一个事务\n- COMMIT；也可以使用COMMIT    WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的  \n- ROLLBACK；有可以使用ROLLBACK    WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改\n- SAVEPOINT    identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT\n- RELEASE SAVEPOINT    identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常\n- ROLLBACK TO identifier；把事务回滚到标记点\n- SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ    UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。\n\n---\n\n**[下列四项中，不属于数据库系统的主要特点的是（   ）。](https://www.nowcoder.com/questionTerminal/800eecdc01a240228910fb48f42087a6)**\n\n```\n正确答案: D  你的答案: D\n\nA、数据结构化\nB、数据的冗余度小\nC、较高的数据独立性\nD、程序的标准化\n```\n\n> 数据库系统的特点 数据结构化 数据共享性高,冗余度低,易扩充 数据独立性高\n\n---\n\n**[下面有关sql 语句中 delete truncate的说法正确的是？（）](https://www.nowcoder.com/questionTerminal/f3053b1c256e471b99a2a7da445a6d47)**\n\n```\n正确答案: A C  你的答案: A C\n\nA、论清理表数据的速度，truncate一般比delete更快\nB、truncate命令可以用来删除部分数据。\nC、truncate只删除表的数据不删除表的结构\nD、delete能够回收高水位\n```\n\n1. 处理效率：drop>trustcate>delete    \n2. drop删除整个表；trustcate删除全部记录，但不删除表；delete删除部分记录    \n3. delete不影响所用extent，高水线保持原位置不动；trustcate会将高水线复位。  \n\n## 计算机网络\n\n\n**[下面对http状态码描述正确的是？（）](https://www.nowcoder.com/questionTerminal/a8e19032005f470f96e1f6c0dde1f1e4)**\n\n```\n正确答案: A D  你的答案: A D\n\nA、1**：这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束\nB、3**：表示服务端无法响应\nC、4**：表示服务端错误\nD、5**：表示服务器端错误\n```\n\n1XX（信息状态码）接受请求正在处理\n2XX（成功状态码） 请求正常处理完毕\n3XX（重定向状态码） 需要附加操作已完成请求\n4XX（客户端错误状态码） 服务器无法处理请求\n5XX（服务器错误状态码） 服务器处理请求出错\n\n---\n\n**[RPC、SQL、NFS属于OSI的哪一层？](https://www.nowcoder.com/questionTerminal/7cf6990ea2e345b6bc96d882944c4d6b)**\n\n```\n正确答案: C  你的答案: C\n\nA、应用层\nB、表示层\nC、会话层\nD、传输层\n```\n\n> 第一层：物理层\n> 第二层：数据链路层 802.2、802.3ATM、HDLC、FRAME RELAY \n> 第三层：网络层 IP、IPX、APPLETALK、ICMP \n> 第四层：传输层 TCP、UDP、SPX \n> 第五层：会话层 RPC、SQL、NFS 、X WINDOWS、ASP\n> 第六层：表示层 ASCLL、PICT、TIFF、JPEG、 MIDI、MPEG \n> 第七层：应用层 HTTP、FTP、SNMP等\n\n\n## Java\n\n**[下列代码输出结果为（）](https://www.nowcoder.com/questionTerminal/8b7e3edf00d646afb15319c31206ad31)**\n\n```java\nclass Animal{\n    public void move(){\n        System.out.println(\"动物可以移动\");\n    }\n}\nclass Dog extends Animal{\n    public void move(){\n        System.out.println(\"狗可以跑和走\");\n    }\n    public void bark(){\n        System.out.println(\"狗可以吠叫\");\n    }\n}\npublic class TestDog{\n    public static void main(String args[]){\n        Animal a = new Animal();\n        Animal b = new Dog(); \n        a.move();\n        b.move();\n        b.bark();\n    }\n}\n\n正确答案: D   你的答案: D\n\nA、 动物可以移动\n	狗可以跑和走\n	狗可以吠叫\n\nB、 动物可以移动\n    动物可以移动\n    狗可以吠叫\n\nC、 运行错误\n\nD、 编译错误\n```\n\n\n编译看左边，运行看右边。  父类型引用指向子类型对象，无法调用只在子类型里定义的方法\n\n---\n\n**[下面关于垃圾收集的说法正确的是](https://www.nowcoder.com/questionTerminal/c6586555a3774654a663c3141688aba5)**\n\n```\n正确答案: D  你的答案: D\n\nA、一旦一个对象成为垃圾，就立刻被收集掉。\nB、对象空间被收集掉之后，会执行该对象的finalize方法\nC、finalize方法和C++的析构函数是完全一回事情\nD、一个对象成为垃圾是因为不再有引用指着它，但是线程并非如此\n```\n\n> 以前我是堆，你是栈\n> 你总是能精准的找到我，给我指明出路\n> 后来有一天我明白了\n> 我变成了栈，你却隐身堆海\n> 我却找不到你了，空指针了\n>\n> 我不愿意如此，在下一轮full gc前\n> 我找到了object家的finalize\n> 又找到了你，这次我不会放手\n>\n> 在世界重启前，一边躲着full gc一边老去\n\n**1、在java中，对象的内存在哪个时刻回收，取决于垃圾回收器何时运行。** \n\n**2、**一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法， 并且在**下一次**垃圾回收动作发生时，才会**真正的**回收对象占用的内存（《java 编程思想》） \n\n**3、在C++中，对象的内存在哪个时刻被回收，是可以确定的，在C++中，析构函数和资源的释放息息相关，能不能正确处理析构函数，关乎能否正确回收对象内存资源。**\n\n**在java中，对象的内存在哪个时刻回收，取决于垃圾回收器何时运行**，在java中，所有的对象，包括对象中包含的其他对象，它们所占的内存的回收都依靠垃圾回收器，因此不需要一个函数如C++析构函数那样来做必要的垃圾回收工作。当然存在本地方法时需要finalize()方法来清理本地对象。在《java编程思想》中提及，finalize()方法的一个作用是用来回收“本地方法”中的本地对象 \n\n4、**“但是线程并非如此”不理解，希望大佬补充**\n\n---\n**[下面哪段程序能够正确的实现了GBK编码字节流到UTF-8编码字节流的转换：](https://www.nowcoder.com/questionTerminal/093bfa948d144ce3b0a68b938ae8b4ec)**\n\n```java\nbyte[] src,dst;\n\n正确答案: B  你的答案: B\n\nA、dst=String.fromBytes(src，\"GBK\").getBytes(\"UTF-8\")\nB、dst=new String(src，\"GBK\").getBytes(\"UTF-8\")\nC、dst=new String(\"GBK\"，src).getBytes()\nD、dst=String.encode(String.decode(src，\"GBK\"))，\"UTF-8\" )\n```\n\n> 选B，先通过GBK编码还原字符串，在该字符串正确的基础上得到“UTF-8”所对应的字节串。\n\n---\n\n**[socket编程中，以下哪个socket的操作是不属于服务端操作的（）](https://www.nowcoder.com/questionTerminal/38fb0886232b42b6a542c288d256eee1)** \n\n```\n正确答案: C  你的答案: C\n\nA、accept\nB、listen\nC、connect\nD、close\n```\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/b7b9ab2339dc68d8e38e8c342941b292.png) \n\nTCP客户端： \n\n1. 建立连接套接字，设置Ip和端口监听，socket() \n2. 建立连接 connect \n3. write() 获取网络流对象 发送数据 \n4. read()获取网络流对象 接收数据 \n5. 关闭套接字   \n\n\nTCP服务器端\n\n1. 建立端口监听 socket() \n2. 绑定指定端口 bind() \n3. listen 进行端口监听 \n4. accept() 阻塞式 直到有客户端访问 \n5. read()获取客户端发送数据 \n6. write()发送返回数据 \n7. close关闭端口监听 \n\n---\n\n**[下面关于volatile的功能说法正确的是哪个](https://www.nowcoder.com/questionTerminal/81888b413fae42348429b845242c4edd)**\n\n```\n正确答案: B C  你的答案: B C\n\nA、原子性\nB、有序性\nC、可见性\nD、持久性\n```\n\n> synchronized保证三大性，原子性，有序性，可见性，volatile保证有序性，可见性，不能保证原子性\n\n\n---\n\n**[以下哪些jvm的垃圾回收方式采用的是复制算法回收](https://www.nowcoder.com/questionTerminal/795b066b67c84478aec4dc400b3d0153)**\n\n```\n正确答案: A D  你的答案: A D\n\nA、新生代串行收集器\nB、老年代串行收集器\nC、并行收集器\nD、新生代并行回收收集器\nE、老年代并行回收收集器\nF、cms收集器\n```\n\n两个最基本的java回收算法：**复制算法和标记清理算法** \n\n复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法\n\n标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出\n\n标记整理算法：多了碎片整理，整理出更大的内存放更大的对象\n\n两个概念：新生代和老年代\n新生代：初始对象，生命周期短的\n老年代：长时间存在的对象\n整个java的垃圾回收是新生代和老年代的协作，这种叫做分代回收。 \n\n> Serial New收集器是针对新生代的收集器，采用的是复制算法\n> Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理\n> Parallel  Scavenge（并行）收集器，针对新生代，采用复制收集算法\n> Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理\n> Parallel  Old（并行）收集器，针对老年代，标记整理\n> CMS收集器，基于标记清理\n> G1收集器：整体上是基于标记 整理 ，局部采用复制\n>\n> 综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。\n\n---\n\n**[假如某个JAVA进程的JVM参数配置如下：`-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3 `请问eden区最终分配的大小是多少？](https://www.nowcoder.com/questionTerminal/d712bfe6954140958c953adcb6bf04d1)**\n\n```\n正确答案: C  你的答案: C\n\nA、64M\nB、500M\nC、300M\nD、100M\n```\n\n`Xms` 起始内存\n`Xmx` 最大内存\n`Xmn` 新生代内存\n`Xss` 栈大小。 就是创建线程后，分配给每一个线程的内存大小\n`-XX:NewRatio=n`:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4\n`-XX:SurvivorRatio=n`:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5\n`-XX:MaxPermSize=n`:设置持久代大小\n\n收集器设置\n`-XX:+UseSerialGC`:设置串行收集器\n`-XX:+UseParallelGC`:设置并行收集器\n`-XX:+UseParalledlOldGC`:设置并行年老代收集器\n`-XX:+UseConcMarkSweepGC`:设置并发收集器\n\n垃圾回收统计信息\n`-XX:+PrintGC`\n`-XX:+PrintGCDetails`\n`-XX:+PrintGCTimeStamps`\n`-Xloggc:filename`\n\n并行收集器设置\n`-XX:ParallelGCThreads=n`:设置并行收集器收集时使用的CPU数。并行收集线程数。\n`-XX:MaxGCPauseMillis=n`:设置并行收集最大暂停时间\n`-XX:GCTimeRatio=n`:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)\n\n并发收集器设置\n`-XX:+CMSIncrementalMode`:设置为增量模式。适用于单CPU情况。\n`-XX:ParallelGCThreads=n`:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。\n\n---\n\n**[要使某个类能被同一个包中的其他类访问，但不能被这个包以外的类访问，可以( )](https://www.nowcoder.com/questionTerminal/fe708884a2074763b6d5d1dd62a52817)**\n\n```\n正确答案: A   你的答案: A\n\nA、让该类不使用任何关键字\nB、使用private关键字\nC、使用protected关键字\nD、使用void关键字\n```\n\n> default和protected的区别是： \n> 前者只要是外部包，就不允许访问。 \n> 后者只要是子类就允许访问，即使子类位于外部包。\n>\n> 总结：default拒绝一切包外访问；protected接受包外的子类访问 \n\n![img](https://img-blog.csdnimg.cn/img_convert/6519996d6f04d348cf137fb3ce8f96e4.png)  \n\n\n**[jvm中垃圾回收分为scanvenge gc和full GC，其中full GC触发的条件可能有哪些](https://www.nowcoder.com/questionTerminal/6e9fadc9f3234551bd92d6331a14607d)**\n\n```\n正确答案: C D E  你的答案: C D E\n\nA、栈空间满\nB、年轻代空间满\nC、老年代满\nD、持久代满\nE、System.gc()\n```\n\n垃圾收集机制：新生代、老年代、持久代 ![img](https://img-blog.csdnimg.cn/img_convert/473535d0278cf5124fe05fafa020b672.png)\n\n1. 新生代：（1）所有对象创建在新生代的Eden区，当Eden区满后触发新生代的Minor  GC，将Eden区和非空闲Survivor区存活的对象复制到另外一个空闲的Survivor区中。（2）保证一个Survivor区是空的，新生代Minor  GC就是在两个Survivor区之间相互复制存活对象，直到Survivor区满为止。\n2. 老年代：当Survivor区也满了之后就通过Minor GC将对象复制到老年代。老年代也满了的话，就将触发Full  GC，针对整个堆（包括新生代、老年代、持久代）进行垃圾回收。\n3. 持久代：持久代如果满了，将触发Full GC。\n\n---\n\n**[关于java集合下列说法不正确的有哪些（）](https://www.nowcoder.com/questionTerminal/3dbb60125c2b47918b03ecb112b9c2cb)**\n\n```\n正确答案: A B D  你的答案: A B D\n\nA、HashSet 它是线程安全的，不允许存储相同的对象\nB、ConcurrentHashMap 它是线程安全的，其中存储的键对象可以重复，值对象不能重复\nC、Collection接口是List接口和Set接口的父接口，通常情况下不被直接使用\nD、ArrayList线程安全的，允许存放重复对象\n```\n\n\n**线程安全(Thread-safe)的集合对象：**  \n\n- Vector\n- HashTable\n- StringBuffer     \n\n**非线程安全的集合对象：**  \n\n- ArrayList      \n- LinkedList      \n- HashMap      \n- HashSet \n- TreeMap      \n- TreeSet \n- StringBulider\n\n---\n\n**[若有定义语句： int a=10 ; double b=3.14 ; 则表达式 \'A\'+a+b 值的类型是（）](https://www.nowcoder.com/questionTerminal/460e40f8824244efaf73ae088724f5f3)**\n\n```\n正确答案: C  你的答案: C\n\nA、char\nB、int\nC、double\nD、float\n```\n\n> char < short < int < float < double 不同类型运算结果类型向右边靠齐。\n\n---\n\n**[JVM内存不包含如下哪个部分( )](https://www.nowcoder.com/questionTerminal/04c442aaf1e14bf9819075cc1f29d899)** \n\n```\n正确答案: D  你的答案: D\n\nA、Stacks\nB、PC寄存器\nC、Heap\nD、Heap Frame\n```\nJVM内存五大区域\n\n![img](https://img-blog.csdnimg.cn/img_convert/068228de4fb1e0c052335193fabd08e6.png)\n\n---\n\n**[关于下列程序段的输出结果，说法正确的是：（  ）](https://www.nowcoder.com/questionTerminal/9316826838a644b3a66ff1e9e610eb34)**      \n\n```java\npublic class MyClass{\n    static int i;\n    public static void main(String   argv[]){\n        System.out.println(i);\n    }\n}\n\n正确答案: D  你的答案: D\n\nA、有错误，变量i没有初始化。\nB、null\nC、1\nD、0\n\n```\n\n> 类变量在不设置初始值时，会进行默认值赋值，而局部方法中声明的变量则必须进行初始化，他不会进行默认值赋值。\n\n---\n\n**[以下程序执行的结果是：](https://www.nowcoder.com/questionTerminal/27a89bce14c242d1a4161fbeca2b6b7e)** \n\n```java\nclass X{\n	Y y=new Y();\n	public X(){\n		System.out.print(\"X\");\n	}\n}\nclass Y{\n	public Y(){\n		System.out.print(\"Y\");\n	}\n}\npublic class Z extends X{\n	Y y=new Y();\n	public Z(){\n		System.out.print(\"Z\");\n	}\n	public static void main(String[] args) {\n		new Z();\n	}\n}\n\n正确答案: C   你的答案: C\n\nA、ZYXX\nB、ZYXY\nC、YXYZ\nD、XYZX\n```\n\n初始化过程： \n\n1. 初始化父类中的静态成员变量和静态代码块  ； \n2. 初始化子类中的静态成员变量和静态代码块  ； \n3. 初始化父类的普通成员变量和代码块，再执行父类的构造方法；\n4. 初始化子类的普通成员变量和代码块，再执行子类的构造方法； \n\n执行过程：\n\n（1）初始化父类的普通成员变量和代码块，执行`Y y=new Y();`输出Y \n（2）再执行父类的构造方法；输出X\n（3）初始化子类的普通成员变量和代码块，执行`Y y=new Y();`输出Y   \n（4）再执行子类的构造方法；输出Z\n（5）所以输出YXYZ\n\n\n\n## 笔记\n\n**[UNIX操作系统是著名的（）](https://www.nowcoder.com/questionTerminal/a1b1da8583b9490fa91e319bd090ca2e)**\n\n```\n正确答案: B  你的答案: B\n\nA、多道批处理系统\nB、分时系统\nC、实时系统\nD、分布式系统\n```\n\n\n**操作系统分类**\n\n[批处理操作系统](http://baike.baidu.com/item/批处理操作系统) （Batch Processing Operating System）它的特点是：多道和成批处理。\n\n[分时操作系统](http://baike.baidu.com/item/分时操作系统)(Time Sharing Operating System，简称TSOS)  分时系统具有多路性、交互性、“独占”性和及时性的特征。多路性指，伺时有多个用户使用一台计算机，宏观上看是多个人同时使用一个CPU，微观上是多个人在不同时刻轮流使用CPU。交互性是指，用户根据系统响应结果进一步提出新请求(用户直接干预每一步)。“独占”性是指，用户感觉不到计算机为其他人服务，就像整个系统为他所独占。及时性指，系统对用户提出的请求及时响应。\n\n[实时操作系统](http://baike.baidu.com/item/实时操作系统)(Real Time Operating System，简称RTOS)  实时操作系统要追求的目标是：对外部请求在严格时间范围内做出反应，有高可靠性和完整性。其主要特点是资源的分配和调度首先要考虑实时性然后才是效率。此外，实时操作系统应有较强的容错能力。\n\n[网络操作系统](http://baike.baidu.com/item/网络操作系统)（Network Operating System，简称NOS）通常运行在服务器上的操作系统，是基于计算机网络的，其目标是相互通信及资源共享。\n\n[分布式操作系统](http://baike.baidu.com/item/分布式操作系统)  (Distributed Software Systems)是为分布计算系统配置的操作系统。大量的计算机通过网络被连结在一起，可以获得极高的运算能力及广泛的数据共享。\n\n分布式操作系统是网络操作系统的更高形式，它保持了网络操作系统的全部功能，而且还具有透明性、可靠性和高性能等。网络操作系统和分布式操作系统虽然都用于管理分布在不同地理位置的计算机，但最大的差别是：网络操作系统知道确切的网址，而分布式系统则不知道计算机的确切地址；分布式操作系统负责整个的资源分配，能很好地隐藏系统内部的实现细节，如对象的物理位置等。这些都是对用户透明的。\n\n---\n\n**[计算机内的传输是 （）传输，而通信线路上的传输是（）传输。](https://www.nowcoder.com/questionTerminal/00560b154d994da0846e4c8e13b2a626)**\n\n```\n正确答案: A  你的答案: A\n\nA、并行，串行\nB、串行，并行\nC、并行，并行\nD、串行，串行\n```\n\n\n并行数据传输: 是在传输中有多个数据位同时在设备之间进行的传输.一个编了码的字符通常是由若干位二进制数表示,如用ASCII码编码的符号是由8位二进制数表示的,则并行传输ASCII编码符号就需要8个传输信道,使表示一个符号的所有数据位能同时沿着各自的信道并排的传输.。\n\n串行数据传输:是在传输中只有1个数据位在设备之间进行的传输.对任何一个由若干位二进制表示的字符,串行传输都是用一个传输信道,按位有序的对字符进行传输。\n\n区别: 串行传输的速度比并行传输的速度要慢得多,但费用低.并行传输适用距离短,而串行传输适用远距离传输\n\n---\n\n**[下面哪项技术可以用在WEB开发中实现会话跟踪实现？](https://www.nowcoder.com/questionTerminal/8d86bb29952642169e816d519f8417f3)**\n\n```\n正确答案: A B C D  你的答案: A B C D\n\nA、session\nB、Cookie\nC、地址重写\nD、隐藏域\n```\n\n会话跟踪是一种灵活、轻便的机制，它使Web上的状态编程变为可能。\n\nHTTP是一种无状态协议，每当用户发出请求时，服务器就会做出响应，客户端与服务器之间的联系是离散的、非连续的。当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。当一个客户在多个页面间切换时，服务器会保存该用户的信息。\n\n有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。\n\n1. 隐藏表单域：<input type=\"hidden\">，非常适合步需要大量数据存储的会话应用。\n2. URL重写:URL可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。\n3. Cookie:一个Cookie是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为HTTP响应的一部分传送到客户端，客户端被请求保存Cookie值，在对同一服务器的后续请求使用一个Cookie头标将之返回到服务器。与其它技术比较，Cookie的一个优点是在浏览器会话结束后，甚至在客户端计算机重启后它仍可以保留其值\n4. Session：使用  setAttribute(String str,Object obj)方法将对象捆绑到一个会话\n\n---\n\n**[Windows  操作系统中，文件组织采用（）目录结构。](https://www.nowcoder.com/questionTerminal/dc12220c61044df6b4d3105020e220ab)**\n\n```\n正确答案: C  你的答案: C\n\nA、分区\nB、关系型\nC、树型\nD、网状\n```\n> windows操作系统的目录结构是树形结构。就像一棵树，它的树干就是根目录，然后第一个分枝之后是第一层目录\n\n---\n\n**[目录在linux文件系统中是以怎样的形式存在的？](https://www.nowcoder.com/questionTerminal/39c85d760469456aa105ea30d591c109)**\n\n```\n正确答案: B  你的答案: B\n\nA、文件夹\nB、文件\nC、inode\nD、软链接\n```\n\n> Linux系统下，一切都是文件，硬件设备也是文件\n\n---\n\n**[下列进程通信机制中， UNIX 系统中没有采用的机制是（ ）](https://www.nowcoder.com/questionTerminal/5209ef4738724f659ea658fd44b3c83e)**\n\n```\n正确答案: B  你的答案: B\n\nA、信号量集\nB、管程机制\nC、软中断信号\nD、套接字\n```\n\nLinux进程间通信：管道、信号、消息队列、共享内存、信号量、套接字(socket) \n\nLinux线程间通信：互斥量（mutex），信号量，条件变量 \n\nWindows进程间通信：管道、消息队列、共享内存、信号量（semaphore）、套接字(socket) \n\nWindows线程间通信：互斥量（mutex），信号量（semaphore）、临界区（critical section）、事件（event） \n\n---\n> IPv4地址32位\n> MAC地址48位\n> IPv6地址128位 \n\n**网络状态码**\n\n| 状态码 | 英文                            | 解释                                                         |\n| :----- | :------------------------------ | ------------------------------------------------------------ |\n| 100    | Continue                        | 继续。客户端应继续其请求                                     |\n| 101    | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |\n| 200    | OK                              | 请求成功。一般用于GET与POST请求                              |\n| 201    | Created                         | 已创建。成功请求并创建了新的资源                             |\n| 202    | Accepted                        | 已接受。已经接受请求，但未处理完成                           |\n| 203    | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |\n| 204    | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |\n| 205    | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |\n| 206    | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |\n| 300    | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |\n| 301    | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |\n| 302    | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |\n| 303    | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |\n| 304    | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |\n| 305    | Use Proxy                       | 使用`***`。所请求的资源必须通过`***`访问                     |\n| 306    | Unused                          | 已经被废弃的HTTP状态码                                       |\n| 307    | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |\n| 400    | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |\n| 401    | Unauthorized                    | 请求要求用户的身份认证                                       |\n| 402    | Payment Required                | 保留，将来使用                                               |\n| 403    | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |\n| 404    | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面 |\n| 405    | Method Not Allowed              | 客户端请求中的方法被禁止                                     |\n| 406    | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |\n| 407    | Proxy Authentication Required   | 请求要求`***`的身份认证，与401类似，但请求者应当使用`***`进行授权 |\n| 408    | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |\n| 409    | Conflict                        | 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突 |\n| 410    | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |\n| 411    | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |\n| 412    | Precondition Failed             | 客户端请求信息的先决条件错误                                 |\n| 413    | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |\n| 414    | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |\n| 415    | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |\n| 416    | Requested range not satisfiable | 客户端请求的范围无效                                         |\n| 417    | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |\n| 500    | Internal Server Error           | 服务器内部错误，无法完成请求                                 |\n| 501    | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |\n| 502    | Bad Gateway                     | 作为网关或者***工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |\n| 503    | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |\n| 504    | Gateway Time-out                | 充当网关或***的服务器，未及时从远端服务器获取请求            |\n| 505    | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |\n\n---\n\n**设计模式分类**\n\n**一、创建型模式**\n\n工厂模式（Factory Pattern）\n抽象工厂模式（Abstract Factory Pattern）\n单例模式（Singleton Pattern）\n建造者模式（Builder Pattern）\n原型模式（Prototype Pattern）\n\n**二、结构型模式**\n\n适配器模式（Adapter Pattern）\n桥接模式（Bridge Pattern）\n过滤器模式（Filter、Criteria Pattern）\n组合模式（Composite Pattern）\n装饰器模式（Decorator Pattern）\n外观模式（Facade Pattern）\n享元模式（Flyweight Pattern）\n代理模式（Proxy Pattern）\n\n**三、行为型模式**\n\n责任链模式（Chain of Responsibility Pattern）\n命令模式（Command Pattern）\n解释器模式（Interpreter Pattern）\n迭代器模式（Iterator Pattern）\n中介者模式（Mediator Pattern）\n备忘录模式（Memento Pattern）\n观察者模式（Observer Pattern）\n状态模式（State Pattern）\n空对象模式（Null Object Pattern）\n策略模式（Strategy Pattern）\n模板模式（Template Pattern）\n访问者模式（Visitor Pattern）\n\n---\n\n> **常用 ASCII 码值**\n>\n> 空格为 32\n> 数字0为 48\n> “A”为 65\n> “a”值为 97\n\n---\n\n**JVM常用命令**\n\n1. jps：查看本机java进程信息。\n2. jstack：打印线程的栈信息，制作线程dump文件。\n3. jmap：打印内存映射，制作堆dump文件\n4. jstat：性能监控工具\n5. jhat：内存分析工具\n6. jconsole：简易的可视化控制台\n7. jvisualvm：功能强大的控制台\n\n---\n\n**数据库系统的三级模式结构**\n\n数据库系统的三级模式结构是指数据库系统是由**外模式**、**模式**和**内模式**三级构成.\n 为了能够在系统内部实现这 3 个抽象层次的联系和转换，数据库管理系统在这三级模式之间提供了两层映像：\n **外模式/模式映像**（映像定义通常包含在各自外模式的描述中，保证了数据与程序的逻辑独立性，简称**数据的逻辑独立性**，应用程序是依据外模式编写的）\n **模式/内模式映像**（包含在模式描述中，此映像是唯一的，它定义了数据全局逻辑结构与存储结构之间的对应关系，它保证了数据与程序的物理独立性，所以称为**数据的物理独立性**）\n\n---\n\n**1NF,2NF,3NF**\n\n1NF : 属性是原子性的，即不可拆分的；例如姓名这个属性是一般不可拆分的；而社会保险号如果是由出生年月日与姓名缩写构成的话，就是可拆分的：包含可拆分的含义：出生年月日，姓名； 是否可拆分取决于对含义的解释；\n\n2NF：解决了非主键属性对主键属性的部分依赖；如表（A, B, C, D），其中ABCD代表属性，假设（A,  B）是主键，若C只依赖于B，则这个表是不符合2NF的，可拆分为（A, B, D）与  （B,  C）两张表；很明显，如果主键只有一个属性，那么肯定是2NF\n\n3NF：解决了非主键属性对主键属性的传递依赖；如表（A,B,C,D），如果主键是A,  而B依赖于A，C依赖于B，则这个表有传递依赖，是不符合3NF的；\n\n范式的目的是为了**减少/消除冗余**\n\n---\n\n**共享锁/排他锁**\n\n共享锁【S锁】，又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。\n\n排他锁【X锁】，又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。\n\n---\n\n**事务的特性**\n\n原子性（Atomicity）：是事务执行的最小单位。不允许分割。事务的原子性确保动作要么全部成功，要么全部失败\n一致性（Consistency）：执行事务的前后，数据保持不变\n隔离性（Isolation）：并发访问事务时，一个用户的事务数据不能被其他事务所干扰。各并发事务之间的数据库是独立的\n持久性（Durability）：一个事物被提交后，他对数据库的数据改变时持久的。即使数据库发生故障，也不应该对数据有影响',24,'日常随笔','java,操作系统,数据结构,计算机网络',1,165,0,0,'2021-02-22 19:05:18','2021-02-22 19:05:18'),(13,'测试文章','这是测试文章的摘要','哈哈哈哈哈哈哈哈哈\n',24,'日常随笔','123456',1,0,0,1,'2021-03-01 18:28:02','2021-03-01 18:28:02'),(14,'java123456','asdadad','adsadasdsada',24,'日常随笔','4566854787',1,0,0,1,'2021-03-02 18:01:06','2021-03-02 18:01:06'),(15,'一篇测试文章','一段摘要啦啦啦啦啦啦啦','hhhhhhhhajksdhajkdhj skl',24,'日常随笔','hdgsajhgdjha',1,0,0,1,'2021-03-02 18:04:16','2021-03-02 18:04:16'),(16,'计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI 模型”','简单介绍计算机网络通讯的基础知识','# [计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI 模型”](https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html)\n\n**文章目录**\n\n[★本文的目标读者](#head-1)  \n[★基本概念](#head-2)  \n[★从“分层”到“参考模型”](#head-3)  \n[★OSI 概述](#head-4)  \n[★物理层：概述](#head-5)  \n[★物理层：具体实例](#head-6)  \n[★链路层：概述](#head-7)  \n[★链路层：具体实例](#head-8)  \n[★网络层：概述](#head-9)  \n[★网络层：具体实例](#head-10)  \n[★传输层：概述](#head-11)  \n[★传输层：具体实例](#head-12)  \n[★业务层（OSI 上三层）：概述](#head-13)  \n[★业务层（OSI 上三层）：具体实例](#head-14)  \n[★杂项](#head-15)  \n[★参考书目](#head-16)  \n\n\n## ★本文的目标读者\n\n  \n　　今天这篇的标题是“扫盲”，也就是说：即使那些完全不懂 IT 领域，也不懂通讯领域的读者，依然能看懂（至少能看懂一部分）。为了做到这点，俺会尽量使用通俗的比喻，并适当加一些示意图。  \n　　另外，就算你已经比较了解网络通讯领域，本文中提到的某些部分，也可能是你所不知道的。也就是说：懂行的同学，看看此文，也会有帮助。  \n　　本文的标题特地强调了【系统性】——俺希望这篇教程能帮助读者对“计算机网络”这个领域进行系统性学习（何为“系统性学习”？\n　　为了做到【系统性】这个目的，这篇教程很长。俺开博12年，这篇的长度估计能排到前5名。建议大伙儿慢慢看，不要着急。  \n  \n  \n\n## ★基本概念\n\n  \n　　为了足够通俗，俺先要介绍一些基本概念。  \n  \n\n### ◇信道（[channel](https://en.wikipedia.org/wiki/Communication_channel)）\n\n  \n　　这是通讯领域非常基本的概念，肯定要先聊聊它。  \n　　通俗地说，信道就是“传送信息的通道”。  \n  \n\n### ◇信道的类型\n\n  \n　　首先，信道可以从广义上分为“物理信道 ＆ 逻辑信道”。  \n　　顾名思义，“物理信道”就是直接使用某种【物理介质】来传送信息；至于“逻辑信道”——是基于“物理信道”之上抽象出来的玩意儿（待会儿讲到“协议栈”的时候再聊）。  \n  \n\n### ◇信道的带宽\n\n  \n　　“带宽”指的是：某个信道在单位时间内最大能传输多少比特的信息。  \n　　请注意：  \n　　电气领域 ＆ 计算机领域都有“带宽”这个概念，但两者的定义不太一样。电气领域所说的“带宽”指的是“模拟带宽”，单位是“赫兹/Hz”；计算机领域所说的“带宽”指“数字带宽”，单位是“比特率”或“字节率”。  \n　　后续章节提到“带宽”，都是指计算机领域的术语。  \n  \n\n### ◇带宽的单位——容易把外行绕晕\n\n  \n　　“比特率”或“字节率”很容易搞混淆。用英文表示的话——大写字母 `B` 表示【字节】；小写字母 `b` 表示【比特】。  \n  \n　　由于带宽的数字通常很大，要引入“K、M、G”之类的字母表示数量级，于是又引出一个很扯蛋的差异——“10进制”与“2进制”的差异。  \n　　【10进制】的 `K` 表示 1000；`M` 表示 1000x1000（1百万）  \n　　【2进制】的 `K` 表示 1024（2的10次方）；`M` 表示 1024x1024（2的20次方）  \n　　为了避免扯皮，后来国际上约定了一个规矩：对【2进制】的数量级要加一个小写字母 `i`。比如说：`Ki` 表示 1024；`Mi` 表示 1024x1024 ...... 以此类推。  \n　　举例：  \n　　1Kbps 表示“1000比特每秒”  \n　　1KiBps 表示“1024字节每秒”  \n  \n\n### ◇信道的工作模式：单工 VS 半双工 VS 全双工\n\n  \n　　再来说说信道的工作模式。大致可以分为如下三种。为了让大伙儿比较好理解，俺对每一种都举相应的例子。  \n  \n　　**单工（simplex）**  \n　　比如“电台广播”就是典型的【单工】。“电台”可以发信号给“收音机”，但“收音机”【不能】发信号给“电台”。  \n  \n　　**半双工（half-duplex）**  \n　　比如“单条铁路轨道”，就是典型的【半双工】。火车在单条铁轨上，可以有两种运行方向；但对于同一个瞬间，只能选其中一个方向（否则就撞车了）。  \n  \n　　**全双工（full-duplex）**  \n　　比如“光纤”就是典型的【全双工】。在同一根光导纤维中，可以有多个光束【同时相向】传播，互相不会干扰对方。  \n  \n\n### ◇端点\n\n  \n　　为了叙述方便，俺把参与通讯的对象（主体）称作“通讯端点”，简称“端点”。  \n　　这里的“端点”是广义的，可以是硬件（比如某个网卡），也可以是软件（比如某个应用程序）。  \n  \n\n### ◇单播、组播/多播、广播、选播\n\n  \n　　对于“网络通讯”，至少得有 N 个端点参与，并且【N ≥ 2】才有意义。  \n　　当 N 个端点构成一个网络，这时候就会涉及到“单播、组播、广播”这几个概念。  \n　　通俗地说：  \n单播（unicast）——发送给网络中的指定的【单个】端点  \n组播/多播（multicast）——发送给网络中的指定的【多个】端点  \n广播（broadcast）——发送给网络中的【所有】端点  \n选播（anycast）——发送给网络中随机选择的【单个】端点  \n  \n\n### ◇通讯协议（protocol）\n\n  \n　　所谓的“通讯协议”就是：参与通讯的各方所采用的某种【约定】。只有大家都遵守这个约定，才有可能相互传递信息。  \n　　打个比方：如果两个人要用自然语言交流，前提是：双方使用相同（或相互兼容）的自然语言。  \n　　“通讯协议”就类似某种自然语言，参与通讯的多个端点，都必须能理解这个语言。  \n  \n  \n\n## ★从“分层”到“参考模型”\n\n  \n\n### ◇分层\n\n  \n　　在聊“分层”之前，先说说“分工”。比如在一个公司中，通常设有不同的工种/岗位，这就【分工】。  \n　　对于网络通讯也是如此，不太可能用一种通讯协议完成所有的信息传递任务（注：对于特别简单的网络，或许有可能只用单一协议；但如今的网络通讯已经很复杂，用【单个】通讯协议包办所有事情，已经不太可能）  \n　　一旦采用了多种通讯协议，这几种协议之间，该如何配合捏？  \n　　在网络通讯领域，采用的是【分层】的设计思路。多个层次的协议在一起协同工作，技术上称作“协议栈”（洋文叫做“protocol stack”）。  \n  \n\n### ◇协议栈的原理\n\n  \n　　对于多层次的协议栈。每个层次都有各自的“端点”（进行通讯的主体）。处于【同一层次】的两个端点会使用该层次的协议进行通讯（注：同一个层次的协议，可能只有一个，也可能有多个）。  \n　　除了最顶层，每个层次的端点会向其【直接】上层提供“服务”；除了最底层，每个层次的端点会调用【直接】下层提供的“服务”（这里所说的“服务”指某种“编程接口”，技术行话叫 API）。  \n  \n\n![不见图 请翻墙](https://lh3.googleusercontent.com/bK34KOVTYWmZNuIOY-0CxbJn1tR8LV_-78VflTiRK3rFM_YjVPa6lSbdxU58ICNFqTo2ghGjicgekyoZ4CNdFDe7ucMEM3BVHDA48S44mNn7e7Rf-5L3XDxYrjGDUpFp3AvkLDxb78w)  \n（“协议栈”的示意图）\n\n  \n\n![不见图 请翻墙](https://lh5.googleusercontent.com/qfAnnow_Fl7VudJd1GS39MJxLfXymYvKQ7ISRvYoSG4RKl8AltCB2Ru86zf78ABHd3ZrzI6sNF9Z65I9z8-He26A7hSInp-Pf2Quduw26FHGWMb2VK5YK-yLWnG8F2UibWqgzYwGSaU)  \n（“服务”与“协议”之间的关系）\n\n  \n\n### ◇逻辑信道\n\n  \n　　（前一个小节说了）每个层次会向上一个层次提供服务（API 调用）。对上层而言，调用下层提供的 API 发送信息，其效果相当于在使用某种【信道】进行通讯，这也就是俺在 ★基本概念 那个章节所说的“逻辑信道”。  \n  \n\n![不见图 请翻墙](https://lh4.googleusercontent.com/OzflASXF1Xv5c3-eg-RiT4ENcwjZx4jpeVYlj01YI6I-1L-Wgjl3FE47Rc94Dn9JAcTnHGcEES1KcaSSjHkZQeG1iKWgamZWrMtC0QTMpbHnO7NQeZvuMIeS9Sx8pI7gNg7DlakovkY)  \n（“逻辑信道”示意图）\n\n  \n\n### ◇数据格式的原理\n\n  \n　　大部分协议会把要传送的数据切割为 N 份，每一份就是一个数据包。  \n　　通常来说，数据包的格式有如下三部分：  \n\n> 头部  \n> 身体（也称作“有效载荷”）  \n> 尾部（注：很多协议没有尾部）\n\n　　如果你收过快递，可以把“网络数据包”与“快递包裹”作一个对照——  \n数据包的“头/尾”，就类似于快递包裹的【包装袋】。数据包的“身体”，就类似于快递包裹里面的东西。  \n  \n　　对于【相邻】两层的协议，【下】层包含【上】层。也就是说：下层协议的【载荷】就是上层协议的【整体】。  \n　　还是以快递举例：  \n　　假设你从网上买了一台笔记本电脑。电脑出厂时，电脑厂商肯定会提供一个包装盒。快递公司在寄送这台笔记本的时候，又会在笔记本的盒子外面再加一个包装袋。对应到网络协议——“快递公司的包装袋”相当于【下层】协议；“电脑厂商的包装盒”，相当于【上层】协议。  \n  \n\n![不见图 请翻墙](https://lh3.googleusercontent.com/bz_Gg8ow_9ZM4dqw9wEfGaEXZmpusHPT9pwhILsvusYq6XPZa__M5GsfF07xCnoAV-S2udQ0unbuAbUgWqx9vCgF71t7RgQhsgkNL6Ol76wueKdvWU-nukPat8i7VlVFXs2FDrthrt0)  \n（上下层协议的格式及包含关系）\n\n  \n\n### ◇网络分层的参考模型\n\n  \n　　上述所说的“分层 ＆ 协议栈”只是一个抽象的（笼统的）思路。具体要分几层？每一层要干啥事儿？这些都是很有讲究滴！网络技术发展了几十年，已经有很多牛人提出了各种不同的划分方案，称之为“网络分层的参考模型”（为了打字省力，以下简称“模型”）。  \n　　在各种模型中，名气最大的当然是“OSI 模型”（洋文称作“[OSI model](https://en.wikipedia.org/wiki/OSI_model)”）。在后续的章节中，俺会以这个模型为主体，进行介绍。  \n　　除了“OSI 模型”还有一个很出名的模型是“TCP/IP 模型”（因为互联网很成功，它才跟着出名）。  \n　　对“TCP/IP 模型”的分层，不同的文章或书籍，说法不太一样（“3层、4层、5层”皆有），这就引发了一些争议。包括几位热心读者也在博客留言，表达不同意见。为了避免一家之言，贴出维基百科的“[这个链接](https://en.wikipedia.org/wiki/Internet_protocol_suite#Layer_names_and_number_of_layers_in_the_literature)”，其中给出了几种比较有名的说法。  \n　　另外，俺想提醒一下：  \n　　由于本文是基于【OSI 模型】进行展开。对于 TCP/IP 模型到底算几层，这方面的争论【不】影响本文后续的内容。  \n  \n  \n\n## ★OSI 概述\n\n  \n\n### ◇OSI 的历史\n\n  \n　　“OSI”的全称是“Open System Interconnection”。先说说它的历史。  \n　　上世纪70年代，“国际电信联盟”（ITU）想对各国的电信系统（电话/电报）建立标准化的规格；与此同时，“国际标准化组织”（ISO）想要建立某种统一的标准，使得不同公司制造的大型主机可以相互联网。  \n　　后来，这两个国际组织意识到：“电信系统互联”与“电脑主机互联”的性质差不多。于是 ISO 与 ITU 就决定合作，两家一起干。这2个组织的2套班子，从上世纪70年代开始搞，搞来搞去，搞了很多年，一直到1984年才终于正式发布 OSI 标准。  \n  \n\n### ◇OSI 标准的两个组成部分\n\n  \n　　严格来讲，OSI 包括两大部分——  \n其一，抽象的概念模型，也就是前面提到的【OSI model】；  \n其二，针对这个概念模型的具体实现（具体的通讯协议），洋文叫做【OSI protocols】。  \n  \n　　（前面说了）OSI 是由 ISO ＆ ITU 联手搞出来滴。这两个国际组织里面的人，要么是来自各国的电信部门，要么是来自各国的高校学者。总而言之，既有严重的官僚风气，又有明显的学究风气。（正是因为这两种风气叠加，所以搞了很多年，才搞出 OSI）  \n　　OSI 的协议实现（OSI protocols），不客气地说，就是一堆垃圾——据说把 OSI protocols 所有的协议文档，全部打印成 A4 纸，摞起来得有一米多高！是不是很吓人？协议搞得如此复杂，严重违背了 IT 设计领域的 [KISS 原则](https://en.wikipedia.org/wiki/KISS_principle)。  \n　　由于 OSI protocols 实在太复杂，后来基本没人用。但 OSI model 反而广为流传，并且成为“网络分层模型”中名气最大，影响力最广的一个。  \n　　因此，本文后续章节中，凡是提到 OSI，指的是【OSI model】。  \n  \n\n### ◇OSI 模型的7层\n\n  \n　　OSI 模型总共分7层，示意图参见如下表格：  \n\n| 层次 | 中文名 | 洋文名 |\n| --- | --- | --- |\n| 第7层 | 应用层 | Application Layer |\n| 第6层 | 表示层 | Presentation Layer |\n| 第5层 | 会话层 | Session Layer |\n| 第4层 | 传输层 | Transport Layer |\n| 第3层 | 网络层 | Network Layer |\n| 第2层 | 数据链路层 | Data Link Layer |\n| 第1层 | 物理层 | Physical Layer |\n\n（注：为了打字省力，在后续章节把“数据链路层”直接称为“链路层”）\n\n  \n　　考虑到本文是针对一般性读者的【扫盲教程】，俺重点聊第1~4层。搞明白这几个层次之后，有助于你更好地理解网络的很多概念，也有助于你更好地理解很多信息安全的概念。  \n　　网上已经有很多关于 OSI 的文章，可惜大部分写得粗糙——很多文章只是在照抄定义。  \n　　俺曾经写过一篇《[学习技术的三部曲：WHAT、HOW、WHY](https://program-think.blogspot.com/2009/02/study-technology-in-three-steps.html)》，其中提到【理解技术】的不同层次。要想更好地理解 OSI 模型，你得搞明白：为啥需要引入某某层？（请注意：这是一个 WHY 型的问题）  \n　　接下来在讨论 OSI 的每个层次时，俺都会专门写一个小节，谈该层次的【必要性】。搞明白【必要性】，你就知道为啥要引入这个层次。  \n  \n  \n\n## ★物理层：概述\n\n  \n\n### ◇物理层的必要性\n\n  \n　　通俗地说：直接与物理介质打交道的层次，就是物理层。这一层的必要性比较明显。  \n　　因为所有的通讯，归根结底都要依赖于【物理介质】。与物理介质打交道，需要牵涉到很多与【物理学】相关的东东。比如：“无线电通讯”需要关心“频率/波长”；电缆通讯需要跟“电压”打交道；“光纤通讯”需要关心“玻璃的折射率＆光线的入射角” ......  \n　　“物理层”的主要职责是：屏蔽这些细节，使得“物理层”之上的层次不用再去操心物理学。  \n  \n\n### ◇物理信道的类型\n\n  \n　　何为“物理信道”，在本文开篇的“基本概念”已经提到了。  \n　　对于“物理信道”，还可以进一步细分为如下三大类：  \n1\\. 有线信道（比如：双绞线、同轴电缆、光纤、等等）  \n2\\. 无线信道（比如：微波通讯、电台广播、卫星通讯、等等）  \n3\\. 存储信道  \n  \n　　“存储信道”比较少见，很多人没听说过，稍微解释一下。  \n　　假设你要把一大坨信息传送给另一个人，除了用“有线 or 无线”这两种通讯方式，还可以把信息先保存到某种【存储介质】（比如硬盘），然后再把存储介质用某种方式（比如快递）转交给对方。这就是所谓的“存储信道”。  \n  \n\n### ◇[信噪比](https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%99%AA%E6%AF%94)（Signal-to-noise ratio）\n\n  \n　　俺在很多篇关于“学习＆心理学”的博文中提到过【信噪比】这个概念。其实这个概念是从通讯领域借用的术语。  \n　　对于“物理信道”，总是会存在某些环境干扰，称之为“噪声”（Noise）。“信道传输的有用信息”与“无用的干扰噪声”，这两者的比值就是“信噪比”。  \n　　“信噪比”单位是【分贝】。“分贝”洋文叫做“[decibel](https://en.wikipedia.org/wiki/Decibel)”（简写为 dB）。“deci”表示“十进制”；“bel”是为了纪念大名鼎鼎的贝尔（电话它爹）。  \n  \n\n### ◇带宽的限制因素\n\n  \n　　“物理信道”要依赖于物理传输介质。不管使用何种物理介质，都要受限于某些基本的物理学定律（比如“光速上限”）。另外，不管何种物理介质，总是会有或多或少的环境干扰（噪声）。这两个因素导致了：任何“物理信道”的最大传输率总是有限滴。  \n　　由于物理层是最底下的一层，物理层之上的其它层次总是要直接或间接地依赖【物理信道】。因此，其它层次建立的“逻辑信道”，其带宽只会比“物理信道”的最大带宽更小。换句话说：“物理信道”的带宽上限也就是整个协议栈的带宽上限。  \n  \n\n### ◇[多路复用](https://zh.wikipedia.org/wiki/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8)（Multiplexing）\n\n  \n　　一般来说，凡是能实现【长距离】通讯的“物理信道”，都有相当的经济成本。比如铺设“光纤、同轴电缆”都要花钱。无线电通讯虽然免去了铺设线路的成本，但需要竞标购买频段。因此，物理信道非常强调“多路复用”。  \n　　所谓的“多路复用”，通俗地说就是：尽可能地共享物理信道，不要浪费了。  \n　　“多路复用”有很多种类型；不同的类型，原理也不同。为了展示各种不同的原理，俺拿【无线通信】来说事儿。  \n　　无线通信领域的“多路复用”，【至少】有如下几种：  \n  \n　　**频分多路复用/FDM（Frequency-Division Multiplexing）**  \n　　这个最简单，就是根据频率拆分。不同的线路占用不同的频段，互不干扰。（电台广播用的就是这个思路）  \n　　但这个思路的缺点很明显——  \n其一，要依赖足够宽的频段（频段是稀缺资源）；  \n其二，不同线路的流量可能会动态变化。如果某个线路空闲，其占用的频段就浪费了。  \n　　（注：光纤通讯中有个“波分多路复用/WDM”，本质上就是 FDM）  \n  \n　　**时分多路复用/TDM（Time-Division Multiplexing）**  \n　　这种思路只用一个很窄的频段。为了在同一个频道发送多个信道，采用【分时机制】，把时间切割成很小的时间片，每个线路占用一个时间片。周而往复。  \n　　这个思路有点像十字路口的红绿灯——每隔一段时间，其中一条路可以通行。  \n　　这个思路的优点是：可以只使用一个很窄的频段。缺点是：线路越多，每条线路等待越久；即使某个线路空闲，依然会占用时间片（浪费了资源）。  \n  \n　　**码分多路复用/CDM（Code-Division Multiplexing）**  \n　　这种思路采用某种【编码】的技巧，使得多个端点可以在同一个时间点使用同一频段发送数据；由于他们采用不同的编码方式，不会相互干扰。  \n　　一般来说，CDM 要依赖于“扩频技术”（[spread spectrum](https://en.wikipedia.org/wiki/Spread_spectrum)），需占用一个比较宽的频道范围。这算是缺点。但其优点很明显——  \n其一，可以支持 N 个线路（N 动态变化）；  \n其二，即使任何一个线路的流量动态变化，也不会浪费物理信道的资源。  \n　　显然，这种思路明显优于 FDM ＆ TDM。如今在移动通讯领域大名鼎鼎的 CDMA（码分多址），采用的就是这个思路。  \n  \n  \n\n## ★物理层：具体实例\n\n  \n\n### ◇物理层的【协议】\n\n  \n　　物理层的协议主要有如下：  \n[USB 协议](https://en.wikipedia.org/wiki/Universal_Serial_Bus)  \n[蓝牙协议](https://en.wikipedia.org/wiki/List_of_Bluetooth_protocols)的一部分  \n[IEEE 802.11](https://en.wikipedia.org/wiki/IEEE_802.11) 的一部分（Wi-Fi）  \n[IEEE 802.16](https://en.wikipedia.org/wiki/IEEE_802.16)（WiMAX）  \n[IEEE 1394](https://en.wikipedia.org/wiki/IEEE_1394)（火线接口）  \n[RS-232 协议](https://en.wikipedia.org/wiki/RS-232)（串行接口/串口）  \n......  \n（考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。  \n  \n\n### ◇物理层的【协议实现】\n\n  \n　　对于电脑主机（含移动设备），“网卡硬件”包含了物理层的协议实现（参见如下示意图）  \n　　另外，还有一些专门的【1层】网络设备，也提供物理层的功能（参见下一个小节）。  \n  \n\n![不见图 请翻墙](https://lh4.googleusercontent.com/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ)  \n（OSI 模型中，不同层次的协议实现）\n\n  \n\n### ◇物理层相关的【网络设备】\n\n  \n　　**[调制解调器](https://zh.wikipedia.org/wiki/%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83%E5%99%A8)（modem）**  \n　　通俗地说，“调制解调器”就是用来翻译“数字信号 ＆ 模拟信号”。  \n　　在发送信息时，modem 把电脑要发送的“字节流”（数字信号）翻译成“模拟信号”，然后通过物理介质发送出去；当它从物理介质收到“模拟信号”，再翻译成“数字信号”，传回给电脑。  \n　　早期的拨号上网，modem 面对的物理介质是“固话线路”；如今家庭宽带普及，光纤入户，modem 面对的物理介质是“光纤线路”。  \n  \n\n![不见图 请翻墙](https://lh6.googleusercontent.com/nfl3YFl3Bgg13u0xQV0CsGvLSObLDDbGI5wuDcGTulde_klpLWZX9fhpGbiE1SgAJYBDVUtrM4MwjV5Hy6DYA5YC7gKyVaQs-xy_kUdC1jm1hWnAuHdq9q3VDhxoMPbJxEYlL6pONFw)  \n（老式 modem，用于固定电话线路）\n\n  \n　　**[中继器](https://en.wikipedia.org/wiki/Repeater)（repeater）**  \n　　信号在物理介质中传输，会出现【衰减】（不论是“有线 or 无线”都有可能衰减）。“中继器”的作用是【信号增益】，使得信号能传得更远。  \n　　另外，比如“微波通讯”是直线传播，而地球表面有弧度，还有地形的起伏。所以每隔一定距离要建“微波塔”。这玩意儿也相当于“中继器”。  \n  \n\n![不见图 请翻墙](https://lh4.googleusercontent.com/DQOkSWCmJO86Vc1hNJhGONs8j2oHbjS8hlA1XxFL7OIrdPsGT9amhbHzoKHjo8S0aTfVQYgKoBPvP0vEw8lvLEby6OubBeTkHZaV1sikpzIgvVGmLYT_nSmHMZqfJFmUowukZ5pbOoY)  \n（微波塔示意图）\n\n  \n　　**[集线器](https://zh.wikipedia.org/wiki/%E9%9B%86%E7%B7%9A%E5%99%A8)（hub）**  \n　　可以把“集线器”视作更牛逼的“中继器”——“中继器”只有两个口（只能连接两个通讯端点），而“集线器”有多个口（同时连接多个通讯端点）。  \n　　通常所说的“集线器”是指“以太网集线器”。这种设备如今已经逐步淘汰，很少见到了。  \n  \n\n![不见图 请翻墙](https://lh3.googleusercontent.com/JdWYf1BMAyz3Td7XLh7Yuu0YxQLtIzhWHvPhp_xXszrTH-MPiarsWjh9zyL-0Mx0ysRbxANYwaoH6J5OAUC8Hkd58Wx0TIu5D5-AtmWoDpGnGs9aOu7T3Uzc8bYWcUmu5ZCVEH14L44)  \n（老式的10兆以太网集线器）\n\n  \n　　另外，很多同学应该都用过“USB hub”，就是针对 USB 线的“集线器”（“USB 线”也可以视作某种通讯介质）。  \n  \n  \n\n## ★链路层：概述\n\n  \n\n### ◇链路层的必要性\n\n  \n　　**对信息的打包**  \n　　物理层传输的信息，通俗地说就是【比特流】（也就是一长串比特）。但是对于计算机来说，“比特流”太低级啦，处理起来极不方便。“链路层”要干的第一个事情，就是把“比特流”打包成更大的一坨，以方便更上层的协议进行处理。在 OSI 模型中，链路层的一坨，称之为“帧”（frame）。  \n  \n　　**差错控制**  \n　　物理介质的传输，可能受到环境的影响。这种影响不仅仅体现为“噪声”，有时候会出现严重的干扰，导致物理层传输的“比特流”出错（某个比特“从0变1”或“从1变0”）。因此，链路层还需要负责检查物理层的传输是否出错。在 IT 行话中，检测是否出错，称之为“差错控制机制”（后面有一个小节会简单说一下这个话题）。  \n  \n　　**流量控制**  \n　　假设两个端点通过同一个物理信道进行通讯，这两个端点处理信息的速度可能不同。如果发送方输出信息的速度超过接收方处理信息的速度，通讯就会出问题。于是就需要有某种机制来协调，确保发送方的发送速度不会超出接收方的处理速度。在技术行话中，这称之为“流量控制”，简称“流控”。  \n  \n　　**信道复用**  \n　　在上一个章节已经讲到：用于远距离通讯的“物理介质”，总是有成本。因此需要对物理信道进行“多路复用”，就会导致多个端点共用同一个物理信道。如果同时存在多个发送者和多个接收者。接收者如何知道某个信息是发给自己而不是别人？  \n　　另外，某些物理介质可能不支持并发（无法同时发送信息）。某些物理介质可能是【半双工】，所有这些物理层的限制，都使得“多路复用”变得复杂。为了解决这些问题，链路层需要提供了某种相应的机制（协议），术语叫做“介质访问控制”（洋文是“Media Access Control”，简称 MAC）。后续小节会聊它。  \n  \n\n### ◇差错控制\n\n  \n　　为了发现传输的信息是否出错，设计了很多相应的数学算法。这些算法大体分为两类：“检错算法 ＆ 纠错算法”。  \n　　简而言之，“检错算法”只能检测出错误，而“纠错算法”不但能检测出错误，还能纠正错误。很显然，“纠错算法”更牛逼，但是它也更复杂。  \n　　常见的“检错算法”对传输的数据计算出一个【校验值】，接收方收到数据会重新计算校验和，如果算出来不对，就把收到的数据丢弃，让对方重发。“校验算法”的原理类似于《[扫盲文件完整性校验——关于散列值和数字签名](https://program-think.blogspot.com/2013/02/file-integrity-check.html)》一文中提到的“散列算法/哈希算法”。  \n　　“纠错算法”更高级，由于涉及到更多数学，俺就不展开啦。  \n　　对于【无线】物理信道，由于出错的概率更高，并且重新传输数据的成本也更高。所以【无线】通讯的链路层协议，更倾向于用【纠错】机制；作为对比，【有线】通讯的链路层协议，更倾向于用【检错】机制。  \n  \n\n### ◇[MAC 协议](https://en.wikipedia.org/wiki/Medium_access_control)\n\n  \n　　“MAC 协议”用来确保对下层物理介质的使用，不会出现冲突。为了形象，俺拿“铁路系统”来比喻，说明“MAC 协议”的用途。  \n　　假设有一条【单轨】铁路连接 A/B 两地。有很多火车想从 A 开到 B，同时还有很多火车想从 B 开到 A。  \n　　首先，要确保不发生撞车（如果已经有车在 A 开往 B 的途中，那么 B 就不能再发车）；其次，即使是同一个方向的车，出发时间也要错开一个时间间隔。  \n　　所有这些协调工作，都是靠“MAC 协议”来搞定。  \n  \n\n### ◇MAC 地址\n\n  \n　　为了完成上述任务，光有“MAC 协议”还不够，还需要为每一个端点引入【惟一的】标识。这个标识就称作“MAC 地址”。  \n　　通俗地说，每个网卡都内置了一个“MAC 地址”。这个地址是网卡在出厂的时候就已经设置好的，并且用某种机制确保该地址【全球唯一】。  \n  \n　　如何保证 MAC 地址全球唯一捏？简单说一下：  \n　　MAC 地址包含6个字节（48个比特），分为两半。第一部分称作【OUI】，OUI 的24个比特中，其中2个比特有特殊含义，其它22个比特，用来作为网卡厂商的唯一编号。这个编号由国际组织 IEEE 统一分配。  \n　　MAC 地址第二部分的24比特，由网卡厂商自己决定如何分配。每个厂商只要确保自己生产的网卡，后面这24比特是唯一的，就行啦。  \n\n![不见图 请翻墙](https://lh6.googleusercontent.com/p1BJLdyURQLXwjaX9w6zrYxmzkFitCfuXYxEnQ8o2WaciD67PpWKUzx2MM4s7ay2Ds9Ltn4oHERF0uq17z_zaEIZFvRBqDb2U7WUPtAVM9Cve1_BUtd8Emx-073rj3jpizDMZRwdQ5o)  \n（MAC 地址的构成）\n\n  \n　　由于俺在很多安全教程中鼓吹大伙儿使用“[操作系统虚拟机](https://program-think.blogspot.com/2012/10/system-vm-0.html)”，再顺便说说【虚拟网卡】的 MAC 地址。  \n　　“虚拟网卡”是由【虚拟化软件】创建滴。IEEE 也给每个虚拟化软件的厂商（含开源社区）分配了唯一的 OUI。因此，虚拟化软件在创建“虚拟网卡”时，会使用自己的 OUI 生成前面24个比特；后面的24比特，会采用某种算法使之尽可能【随机化】。由于“2的24次方”很大（`224 = 16777216`），碰巧一样的概率很低。  \n　　（注：如果手工修改 MAC 地址，故意把两块网卡的 MAC 地址搞成一样，那确实就做不到唯一性了。并且会导致链路层的通讯出问题）  \n  \n  \n\n## ★链路层：具体实例\n\n  \n\n### ◇链路层的【协议】\n\n  \n　　链路层的协议主要有如下：  \n[MAC 协议](https://en.wikipedia.org/wiki/Media_access_control)（介质访问控制）  \n[LLC 协议](https://en.wikipedia.org/wiki/Logical_link_control)（逻辑链路控制）  \n[ARP 协议](https://en.wikipedia.org/wiki/Address_Resolution_Protocol)（解析 MAC 地址）  \n[IEEE 802.3](https://en.wikipedia.org/wiki/IEEE_802.3)（以太网）  \n[IEEE 802.11](https://en.wikipedia.org/wiki/IEEE_802.11) 的一部分（Wi-Fi）  \n[L2TP 协议](https://en.wikipedia.org/wiki/Layer_2_Tunneling_Protocol)（2层VPN）  \n[PPP 协议](https://en.wikipedia.org/wiki/Point-to-Point_Protocol)（拨号上网）  \n[SLIP 协议](https://en.wikipedia.org/wiki/Serial_Line_Internet_Protocol)（拨号上网）  \n......  \n（考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。  \n  \n\n### ◇链路层的【协议实现】\n\n  \n　　对于电脑主机（含移动设备），“网卡硬件 ＆ 网卡驱动”会包含链路层协议的实现（参见如下示意图）。  \n　　另外，还有一些专门的【2层】网络设备，也提供链路层的功能（参见下一个小节）。  \n  \n\n![不见图 请翻墙](https://lh4.googleusercontent.com/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ)  \n（OSI 模型中，不同层次的协议实现）\n\n  \n\n### ◇链路层相关的【网络设备】\n\n  \n　　**[网络交换机](https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E4%BA%A4%E6%8F%9B%E5%99%A8)（network switch）**  \n　　（注：一般提到“网络交换机”，如果不加定语，指的就是“2层交换机”；此外还有更高层的交换机，在后续章节介绍）  \n　　为啥要有交换机捏？俺拿“以太网的发展史”来说事儿。  \n　　以太网刚诞生的时候，称之为“经典以太网”，电脑是通过【集线器】相连。“集线器”前面提到过，工作在【1层】（物理层），并不理解链路层的协议。因此，集线器的原理是【广播】模式——它从某个网线接口收到的数据，会复制 N 份，发送到其它【每个】网线接口。假设有4台电脑（A、B、C、D）都连在集线器上，A 发数据给 B，其实 C ＆ D 也都收到 A 发出的数据。显然，这种工作模式很傻逼（低效）。由于“经典以太网”的工作模式才“10兆”，所以集线器虽然低效，还能忍受。  \n　　后来要发展“百兆以太网”，再用这种傻逼的广播模式，就不能忍啦。于是“经典以太网”就发展为“交换式以太网”。用【交换机】代替“集线器”。  \n　　交换机是工作在2层（链路层）的设备，能够理解链路层协议。当交换机从某个网线接口收到一份数据（链路层的“帧”），它可以识别出“链路帧”里面包含的目标地址（接收方的 MAC 地址），然后只把这份数据转发给“目标 MAC 地址相关的网线接口”。  \n　　由于交换机能识别2层协议，它不光比集线器的性能高，而且功能也强得多。比如（稍微高级点的）交换机可以实现“MAC 地址过滤、VLAN、QoS”等多种额外功能。  \n  \n　　**[网桥/桥接器](https://zh.wikipedia.org/wiki/%E6%A1%A5%E6%8E%A5%E5%99%A8)（network bridge）**  \n　　“交换机”通常用来连接【同一种】网络的设备。有时候，需要让两台不同网络类型的电脑相连，就会用到【网桥】。  \n　　下面以“操作系统虚拟机”来举例（完全没用过虚拟机的同学，请跳过这个举例）。  \n　　在[这篇博文](https://program-think.blogspot.com/2012/12/system-vm-5.html)，俺介绍了虚拟机的几种“网卡模式”，其中有一种模式叫做【bridge 模式】。一旦设置了这种模式，Guest OS 的虚拟网卡，对于 Host OS 所在的外部网络，是【双向】可见滴。也就是说，物理主机所在的外部网络，也可以看见这块虚拟网卡。  \n　　现在，假设你的物理电脑（Host OS）只安装了【无线网卡】（WiFi），而虚拟化软件给 Guest OS 配置的通常是【以太网卡】。显然，这是两种【不同】的网络。为啥 Guest OS 的以太网卡设置为“bridge 模式”之后，外部 WiFi 网络可以看到它捏？  \n　　奥妙在于——虚拟化软件在内部悄悄地帮你实现了一个“网桥”。这个网桥把“Host OS 的 WiFi 网卡”与“Guest OS 的以太网卡”关联起来。WiFi 网卡收到了链路层数据之后，如果接收方的 MAC 地址对应的是 Guest OS，网桥会把这份数据丢给 Guest OS 的网卡。  \n　　这种网卡模式之所以称作“bridge 模式”，原因就在于此。  \n  \n\n### ◇链路层相关的【软件工具】\n\n  \n　　**嗅探抓包工具（Sniffer）**  \n　　要了解链路层的数据包结构，需要用到“嗅探工具”。这类工具能捕获流经你网卡的所有【链路层】数据包。前面聊“协议栈”的时候说过：下层数据包的载荷就是上层数据包的整体。因此，拿到【链路层】数据包也就意味着：你已经拿到2层之上的所有数据包的信息了。  \n　　有些抓包工具自带图形界面，可以直接显示数据包的内容给你看。还有些只提供命令行（只是把获取的数据包保存为文件），然后要搭配其它图形化的工具来展示数据包的内容。  \n　　抓包的工具有很多，名气最大的是 [Wireshark](https://en.wikipedia.org/wiki/Wireshark)（原先叫做 Ethereal）。  \n  \n　　**ARP 命令**  \n　　首先，ARP 是“MAC 地址解析协议”的洋文名称。该协议根据“IP 地址”解析“MAC 地址”。  \n　　Windows 自带一个同名的 `arp` 命令，可以用来诊断与“MAC 地址”相关的信息。比如：列出当前子网中其它主机的 IP 地址以及对应的 MAC 地址。这个命令在 Linux ＆ Mac OS 上也有。  \n  \n  \n\n## ★网络层：概述\n\n  \n\n### ◇网络层的必要性\n\n  \n　　**路由机制（routing）**  \n　　在 OSI 模型中，链路层本身【不】提供路由功能。你可以通俗地理解为：链路层只处理【直接相连】的两个端点（注：这么说不完全严密，只是帮助外行理解）  \n　　对于某个复杂网络，可能有很多端点，有很复杂的拓扑结构。当拓扑足够复杂，总有一些端点之间【没有直连】。那么，如何在这些【没有直连】的端点之间建立通讯捏？此时就需要提供某种机制，让其它端点帮忙转发数据。这就需要引入“路由机制”。  \n　　为了避免把“链路层”搞得太复杂，路由机制放到“链路层”之上来实现，也就是“网络层”。  \n  \n　　**基于【路由】的地址编码方式**  \n　　链路层已经提供了某种全球唯一的地址编码方式（MAC 地址）。但“MAC 地址”有如下几个问题：  \n其一，它是固定的（虽然可以用技术手段去修改 MAC 地址，但很少这么干）  \n其二，MAC 地址的编码是基于【厂商】，无法体现网络拓扑结构。或者说，“MAC 地址”对于“路由机制”是不够友好滴。  \n　　因此，需要引入一种更抽象（更高层）的地址，也就是“网络层地址”。咱们常说的“IP 地址”，是“网络层地址”的实现方式之一。  \n  \n　　为了帮你理解，举个例子：  \n　　每个人都有身份证号（这就类似于“MAC 地址”）。当某人加入了某个公司，公司会为此人再分配一个“员工号”（这就类似于“网络地址”）。既然有身份证号，为啥公司还要另搞一套“员工编号”捏？因为“员工编号”有额外的好处。比如说：可以把员工号划分为不同的区间，对应不同的部门。这样一来，只要看到员工号，就知道此人来自哪个部门。  \n　　类似道理，每个网卡都有自己固定的 MAC 地址，当这个网卡接入到不同的网络，每次都可以再分配不同的“网络地址”。通过“网络地址”可以看出这个网卡属于哪个网络（对路由比较方便）。  \n  \n　　**网际互联（[internetwork](https://en.wikipedia.org/wiki/Internetworking)）**  \n　　引入“网络层”的另一个目的是：屏蔽不同类型的网络之间的差异，从而有利于【网际互联】（也就是建立“网络的网络”）。  \n　　一般来说，要想联通【异种】网络，就要求每个网络中都有一台主机充当【网关】（gateway）。【网关】起到“中介/翻译”的作用——帮不同的网络翻译协议，使得不同的网络可以互相联通。  \n　　假设【没有】统一的网络层，网关的工作就很难做。就好比说：如果全球没有某种通用的自然语言，就需要培养非常多不同类型的翻译人才（假设有30种主要语言，任意两种互译，就需要几百种不同的翻译人才）。  \n　　反之，如果有了某种统一的网络层标准，问题就好办多了（还是假设有30种主要语言，只要选定某种作为通用语，然后培养29种翻译人才，就可以实现任意两种语言互译）。  \n　　如今的互联网时代，【IP 协议】就是那个充当统一标准的网络层协议。  \n  \n\n![不见图 请翻墙](https://lh3.googleusercontent.com/zrXBFWSDp-D4VebTx73Un03rN3zKCjVL6Ax_VURmxZyaIj_bfr09TwYya1F6GyNz3W5JLmEvzDggkDPYuHpCdHfWjKHDHp-pBVubeDazpi7Ie9CHYbhJkVP1c48JSZJhpKn8zftthOo)  \n（互联网整合了各种类型的网络）\n\n  \n\n### ◇网络拓扑（network topology）\n\n  \n　　网络的拓扑结构有很多种，有简单的，有复杂的。一般来说，再复杂的拓扑，也可以逐步分解为若干简单拓扑的组合。  \n　　对拓扑的研究，有专门一个数学分支（拓扑学）。考虑到本文只是扫盲，俺不可能再去聊“拓扑学”。因此，只挑几种简单的拓扑结构，让大伙儿有个直观的印象。  \n  \n\n![不见图 请翻墙](https://lh5.googleusercontent.com/ccFqOwvxYuPyelLkW1KRh77tNfUR3TCMMSFN0YgJKJSUfBWISxnzj7mRKLvAP5FvCb2YJDZ8aZO7wRKslvltbWm5fn0QJk3uWp5F3xQy_GFXWVx__c1kDD-cV7HHejxuwqvR6ombf_M)  \n（常见的网状拓扑结构：星形拓扑、环形拓扑、总线拓扑、网状拓扑、等等）\n\n  \n　　如今的互联网，整体的拓扑结构超级复杂。但还是可以逐步分解为上述几种基本的拓扑结构。  \n  \n\n![不见图 请翻墙](https://lh3.googleusercontent.com/l2JVK5up10o5jLkXzIgrcNcTBpnXtmeBKxyHqhuxmqDFlAGDF8pXDqHhRfTf7kAeNLYrgnnI0HVElnFE-JKZXpwcC2Y1f12v5bftW4_6KIYQqY-77tI_pE---r3L3Fwle2i0PTgAnEc)  \n（互联网的复杂拓扑，右下角是图中某个小点的放大。  \n为节省大伙儿的翻墙流量，俺贴的是缩小图。点“[这里](https://upload.wikimedia.org/wikipedia/commons/d/d2/Internet_map_1024.jpg)”看原始图）\n\n  \n\n### ◇互联网的拓扑——从“历史”的角度看其健壮性\n\n  \n　　从上面那张图可以看出：互联网拓扑的【局部】有很多是“星形拓扑”（当然也有其它的）。但从【宏观】上看，更像是“网状拓扑”。  \n　　在现实生活中，对于复杂结构，通常都会采用“树状层次结构”，以便于管理。比如：域名系统、公司组织结构、官僚系统 ...... 那为啥互联网的【宏观】拓扑结构是“网状”捏？这就要说到互联网的历史。  \n  \n　　在上世纪50年代（冷战高峰期），美国军方的指挥系统高度依赖于电信公司提供的电话网络。当时的电话网络大致如下——  \n在基层，每个地区有电话交换局，每一部电话都连入当地的交换局。  \n在全国，设有若干个长途局，每个交换局都接入某个特定的长途局（不同地区的交换局通过长途局中转）。  \n　　简而言之，当时美国的电话网络是典型的【多级星形拓扑】。这种拓扑的优点是：简单、高效、便于管理；但缺点是：健壮性很差。从这个案例中，大伙儿可以再次体会到“效率”与“健壮性”之间的矛盾。俺写过一篇很重要的博文（[这里](https://program-think.blogspot.com/2020/04/Government-and-System-Robustness.html)）深入讨论了这个话题。  \n　　话说1957年的时候，苏联成功试射第一颗洲际弹道导弹（ICBM），美国军方开始担心：一旦苏联先用洲际导弹攻击美国，只要把少数几个长途局轰掉，军方的指挥系统就会瘫痪。也就是说，“长途局”已经成为美国军方的【单点故障】（何为“单点故障”？参见[这篇博文](https://program-think.blogspot.com/2015/04/Single-Point-of-Failure.html)）。  \n　　1960年，美国国防部找来大名鼎鼎的兰德公司进行咨询，要求提供一个应对核打击的方案。该公司的研究员 [Paul Baran](https://en.wikipedia.org/wiki/Paul_Baran) 设计了一个方案，把“星形拓扑”改为【网状拓扑】。采用【网状拓扑】的好处在于：即使发生全面核大战，大量骨干节点被摧毁，整个网络也不会被分隔成几个孤岛，军方的指挥系统依然能正常运作。  \n  \n\n![不见图 请翻墙](https://lh5.googleusercontent.com/IE-FTOWlH2Z5OjbyXQ18nnjCRMoQrk1jfjoyIuLApcwU1AGPhu0mFgJL65IkOsvADshV1Fxbfb4bSn54Xy4m08lDE-n-mtnaSYAAGCgIUZSvVZo-8IAPPzFyLUcZdvq_JWsoUOsfdZQ)  \n（左边：互联网诞生前——美国的电话网络　　右边：兰德公司的“Baran 方案”）\n\n  \n　　有了兰德公司的方案，美国军方找到当时最大的电信公司 AT＆T，想要实现这个系统，结果被否决了。AT＆T 高层认为：搞这样一种系统根本不切实际。于是 Baran 的方案中途夭折。  \n　　为啥 AT＆T 反对这个方案捏？一方面，成功的大公司总是有很强的思维定势（关于这点，参见[这篇文章](https://program-think.blogspot.com/2016/04/Andy-Grove-Quotes-on-Leadership.html)）；另一方面，Baran 的设计方案确实很超前——其前瞻性不仅包括“拓扑结构”，而且把当时电信行业的几大核心观念完全颠覆掉了（具体如何颠覆，后续章节还会再聊）。  \n　　时间一晃又过了好多年，到了60年代末，由于一系列机缘巧合，英国佬发现了“Baran 方案”的价值，并据此搞了一个小型的 NPL 网络（NPL 是“国家物理实验室”的缩写）。然后在某次 ACM 会议上，美国佬看到英国佬的论文，才意识到：Baran 方案完全可行。经历了“出口转内销”的命运之后，该方案重新被美国国防部重视。之后，（国防部下属的）“[高级计划研究局](https://zh.wikipedia.org/wiki/%E5%9C%8B%E9%98%B2%E9%AB%98%E7%AD%89%E7%A0%94%E7%A9%B6%E8%A8%88%E5%8A%83%E7%BD%B2)”（ARPA）开始筹建“阿帕网”（ARPANET），才有了如今的互联网。  \n  \n\n### ◇路由的大致原理\n\n  \n　　聊完“拓扑”，再来聊“路由”。  \n　　当主机 A 向主机 B 发送网络层的数据时，大致会经历如下步骤：  \n1.  \nA 主机的协议栈先判断“A B 两个地址”是否在同一个子网（“子网掩码”就是用来干这事儿滴）。  \n如果是同一个子网，直接发给对方；如果不是同一个子网，发给本子网的【默认网关】。  \n（此处所说的“网关”指“3层网关/网络层网关”）  \n2.  \n对于“默认网关”，有可能自己就是路由器；也可能自己不是路由器，但与其它路由器相连。  \n也就是说，“默认网关”要么自己对数据包进行路由，要么丢给能进行路由的另一台设备。  \n（万一找不到能路由的设备，这个数据就被丢弃，于是网络通讯出错）  \n3.  \n当数据到达某个路由器之后，有如下几种可能——  \n3.1  \n该路由器正好是 B 所在子网的网关（与 B 直连），那就把数据包丢给 B，路由过程就结束啦；  \n3.2  \n亦或者，路由器会把数据包丢给另一个路由器（另一个路由器再丢给另一个路由器） ...... 如此循环往复，最终到达目的地 B。  \n3.3  \n还存在一种可能性：始终找不到“主机 B”（有可能该主机“断线 or 关机 or 根本不存在”）。为了避免数据包长时间在网络上闲逛，还需要引入某种【数据包存活机制】（洋文叫做“Time To Live”，简称 TTL）。  \n通常会采用某个整数（TTL 计数）表示数据包能活多久。当主机 A 发出这个数据包的时候，这个“TTL 计数”就已经设置好了。每当这个数据包被路由器转发一次，“TTL 记数”就减一。当 TTL 变为零，这个数据包就死了（被丢弃）。  \n  \n　　对于某些大型的复杂网络（比如互联网），每个路由器可能与其它 N 个路由器相连（N 可能很大）。对于上述的 3.2 情形，它如何判断：该转发给谁捏？  \n　　这时候，“路由算法”就体现出价值啦——  \n一般来说，路由器内部会维护一张【路由表】。每当收到一个网络层的数据包，先取出数据包中的【目标地址】，然后去查这张路由表，看谁距离目标最近，就把数据包转发给谁。  \n　　上面这段话看起来好像很简单，其实路由算法挺复杂滴。考虑到本文是“扫盲性质”，而且篇幅已经很长，不可能再去聊“路由算法”的细节。对此感兴趣的同学，可以去看《[计算机网络](https://docs.google.com/document/d/1XQwaAMzuGuvmq5fCiTDMrh_pTUpCHJJ5C17btTv8kdE/)》的第5章。  \n  \n\n### ◇路由算法的演变史（以互联网为例）\n\n  \n　　（技术菜鸟可以跳过这个小节）  \n　　由于互联网的 IP 协议已经成为“网络层协议”的事实标准，俺简单聊一下互联网的路由机制是如何进化滴。  \n  \n　　**第1阶段：静态全局路由表**  \n　　（前面说了）互联网的前身是“阿帕网/ARPANET”。在阿帕网诞生初期（上世纪70年代），全球的主机很少。因此，早期的路由表很简单，既是“全局”滴，又是“静态”滴。简而言之，每个路由器内部都维护一张“全局路由表”，这个“路由表”包含了全球所有其它路由器的关联信息。每当来了一个数据包，查一下这张全局路由表，自然就清楚要转发给谁，才能最快到达目的地。  \n　　早期的阿帕网，主机的变化比较少，也很少增加路由器。每当出现一个新的路由器，其它路由器的管理员就手工编辑各自的“全局路由表”。  \n　　为了加深大伙儿印象，特意找来两张70年代初的阿帕网拓扑图（注：图中的 IMP 是“Interface Message Processor”的缩写，也就是如今所说的“路由器”）。  \n  \n\n![不见图 请翻墙](https://lh5.googleusercontent.com/lgeICZCix4CsAg_VubQ00XSJr4eMmdOBSyINs3lbGOV25l1slX5K-6L_HHWWnj-sMQlNTVY0b01JzWL-g1zEn5y-VafJHEwLaJIwwqLEaP4I7JzxbMAk_3wvmnHO34NZYkb5rs98BtY)  \n（1973年的阿帕网）\n\n  \n\n![不见图 请翻墙](https://lh6.googleusercontent.com/miI68qcASC4oz00YtHW6Pv_O0nLK_BZ0PWAxs4J5x-yteT2ya0gkiheH_RCIkX6ZX_soaf2tPPWbXNOYqdhtNaNbLA5OJ3w5Ko47pwXK4hmCtKmHrBmvciP1JYnZCwvUvRqlAtGllG8)  \n（1977年的阿帕网）\n\n  \n　　**第2阶段：动态全局路由表**  \n　　后来，“阿帕网/互联网”的规模猛增，路由器数量也跟着猛增，隔三差五都有新的路由器冒出来。再用“静态路由表”这种机制，（编辑路由表的）管理员会被活活累死。于是改用“动态路由表”，并引入某种“路由发现机制”。但“路由表”依然是【全局】滴。  \n  \n　　**第3阶段：动态分级路由表**  \n　　再到后来，全球的路由器越来越多，成千上万，再搞“全局路由表”已经不太现实了——  \n一方面，“全局路由表”越来越大（查询的速度就越来越慢）  \n另一方面，由于互联网的流量越来越大，每来一个数据包都要查表，查询越来越频繁。  \n　　于是，路由器开始吃不消了。为了解决困境，想出一个新招数：引入“分级路由”（hierarchical routing）。所谓的“分级路由”就是：把整个互联网分为多个大区域，每个大区域内部再分小区域，小区域内部再分小小区域 ...... 看到这里，熟悉“数据结构与算法”的同学就会意识到——这相当于构造了一个【树状】层次结构。  \n　　有了这个层次结构，每个路由器重点关注：自己所在的那个最小化区域里面的网络拓扑。如此一来，每个路由器的“路由表”都会大幅度减小。  \n  \n\n![不见图 请翻墙](https://lh5.googleusercontent.com/29WAIkuNnd2KC88vhFr7UG1ozUqnYQzt6k4VDmra_7Fiqu4lG4WKzEskw12GCuZgL8VKGd7aXI3KIqyGWNX8gwSRf_HzY8rDaG2VzFU9dp9q-wWYN1xyUixlefPu_MLtugsWWVBZfkE)  \n（全局路由表 VS 分级路由表）\n\n  \n\n### ◇互联网的路由——从“CAS”的角度看其健壮性\n\n  \n　　去年（2020）俺写了一篇博文《[“政治体制”与“系统健壮性”——基于“复杂性科学”的思考](https://program-think.blogspot.com/2020/04/Government-and-System-Robustness.html)》，其中介绍了“CAS”（复杂自适应系统）的概念。互联网的路由机制，就是一个典型的 CAS。  \n　　如果把互联网视作一个系统，每个公网上的路由器都是一个自适应的主体。假如某个地区的网络流量突然暴涨，骨干网路由器会自动分流；假如因为地震或战争，导致某个地区的骨干网路由器全部下线，周边地区的路由器也会自动避开这个区域 .....  \n　　所有这些工作，【不需要】依靠任何最高指挥中枢，去进行协调。  \n　　相反，如果互联网的路由系统中，设立了某种“中央委员会”进行实时调度，那互联网早就完蛋了，根本无法成长为今天这种规模。  \n  \n\n### ◇网络层的两种交换技术——电路交换（[circuit switching](https://en.wikipedia.org/wiki/Circuit_switching)） VS 分组交换（[packet switching](https://en.wikipedia.org/wiki/Packet_switching)）\n\n  \n　　（技术菜鸟可以跳过这个小节）  \n　　前面聊“互联网诞生”，说到兰德公司的“Baran 方案”。该方案对当时的电信系统提出几大革命性的变化，其中之一就是“分组交换”技术（也称“数据包交换”or“封包交换”）。  \n　　一般来说，网络层的设计有两种截然不同的风格：【电路交换 VS 分组交换】。有时候也分别称之为“有连接的网络层 VS 无连接的网络层”。此处所说的“连接”指的是某种“虚电路”（洋文叫做“[virtual circuit](https://en.wikipedia.org/wiki/Virtual_circuit)”，简称 VC）。  \n  \n　　要理解“虚电路”，首先要从老式的电话系统说起。  \n　　最早期的电话，既没有拨号盘也没有按键，全靠一张嘴。当你拿起电话，先告诉接线员你要打给谁，接线员会用一根跳接线，插入电话交换设备的某个插孔，从而把你的电话机与对方的电话机相连。于是建立了一条两人之间的电话通路，也就是“电路”。你可以把“接线员”想象成某种“人肉路由器” :)  \n  \n\n![不见图 请翻墙](https://lh4.googleusercontent.com/Ry_GjLe2vTj2fr1dnvGbwn4O6JbFbaEYKPKQyP1UMNba0AKt85b_SmM_fZhlnhBePly-ByLsI3v_r978aUKRY4AAG54ws1yPZglIbOuXZOKvP3vqjvqNdX8MOk0L0CW2vhoGpnI-Jcc)  \n（1900年法国巴黎的电话交换局，可以看到接线员在操作电话交换设备）\n\n  \n　　后来发明了“自动电话交换机”，导致“接线员”全体下岗。虽然自动化了，但原理还是一样——当你在电话上拨了某人的号码，电话局的交换机会自动选择一条线路。只有当这条线路建立起来，对方的电话才会响。一旦双方开始通话，双方之间的语音都是通过这条线路传输。并且这条线路是独占的——只要通话不挂断，这条线路就不会再分配给其他人使用。  \n  \n　　前面提到“互联网诞生的历史”，当时军方推动的“Baran 方案”被 AT＆T 断然拒绝。因为这个方案完全颠覆了传统的电话系统——  \n颠覆之1：把“模拟信号”颠覆为“数字信号”（这点比较好理解，俺就不解释了）  \n颠覆之2：把“星形拓扑”颠覆为“网状拓扑”（关于这点，前面的小节已经讨论了）  \n颠覆之3：把“电路交换”颠覆为“分组交换”（这就是本小节的重点）  \n  \n　　为了帮大伙儿理解上述第3点，举个例子：  \n　　假设主机 A 要向主机 B 发送一大坨数据。因为数据太多，肯定要分成好几坨小一点的（分成多个数据包）。如何把这些数据包发送给对方捏？  \n  \n　　**“电路交换”的实现方式**  \n在发送数据之前，要先建立连接通道（通过路由算法，找出 A ＆ B 之间的某条通路）。这条通路就是所谓的“虚电路/VC”。一旦 VC 建立，每一个数据包都是从这条拓扑路径进行路由。  \n  \n　　**“分组交换”的实现方式**  \n在发送数据之前，【不需要】建立通道，让每个数据包独立进行路由。这种情况下，这几个数据包可能会走【不同的】拓扑路径。因此，数据包到达的顺序与发送的顺序【不一定】相同。接收方收到所有数据包之后，还要自己进行排序。  \n　　维基百科上有一个 GIF 动画（[这个链接](https://upload.wikimedia.org/wikipedia/commons/thumb/f/f6/Packet_Switching.gif/480px-Packet_Switching.gif)），比较直观地演示“分组交换/封包交换”的效果。由于这个动画稍微有点大（超过 1MB），俺就不贴到博文中了。  \n  \n　　当时的电话系统主要承载语音传输，“电路交换”显然性能更高。那为啥 Baran 的设计要采用“分组交换”捏？俺又要再次提到【效率 VS 健壮性】之间的矛盾与均衡。  \n　　对于“电路交换”，一旦建立连接，同一个连接的所有数据都走相同的路径（会经过完全相同的路由器）。也就是说，传输的过程中，如果某个路由器挂掉了（网络掉线 or 硬件当机 or 软件崩溃）。那么，该路由器正在处理的 N 个连接全都要报废。而“分组交换”则更加灵活——即使某个路由器挂掉了，后续的数据包会自动转向另外的路由器，损失很小。  \n　　“Baran 方案”之所以采用“分组交换”的设计，因为人家这个方案是提交给军方用来应对【全面核战争】滴，当然要考虑健壮性啦。  \n  \n　　话说这两种交换机制，各有很多支持者，并分裂为两大阵营，分别是：“电信阵营 VS 互联网阵营”。两大阵营的口水战持续了 N 年，都无法说服对方。到了后来设计 OSI 模型的时候，为了保持中立性与通用性，OSI 模型本身并没有强制要求网络层采用哪一种风格。  \n　　经过几十年之后，咱们已经可以看出来：“互联网阵营”占据主导地位。如今，连电信系统都是架构在互联网之上。  \n  \n  \n\n## ★网络层：具体实例\n\n  \n\n### ◇网络层的【协议】\n\n  \n　　网络层的协议有很多。由于“互联网”已经成为全球的事实标准，因此俺只列出属于“互联网协议族”的那些“网络层协议”：  \nIP 协议（含 [IPv4](https://en.wikipedia.org/wiki/IPv4) ＆ [IPv6](https://en.wikipedia.org/wiki/IPv6)）  \n[ICMP](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol)  \n[IGMP](https://en.wikipedia.org/wiki/Internet_Group_Management_Protocol)  \n[IPSec](https://en.wikipedia.org/wiki/IPsec)  \n......  \n（考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。  \n　　对上述这些协议，最重要的当然是 IP 协议。如果你想要深入了解 IP 协议，可以参考如下这本书。关于 IP 协议的书，此书的影响力最大。这本书共3卷，通常只需看第1卷。  \n《[TCP-IP 详解](https://docs.google.com/document/d/1Fw2wSr-MgNm1d_M6F-rF1t_n3LwFWWBHrJt6vcYGta4/)》  \n  \n\n### ◇网络层的【协议实现】\n\n  \n　　对于电脑主机（含移动设备），网络层的协议实现通常包含在操作系统自带的网络模块中（也就是“操作系统协议栈”）。具体参见如下示意图。  \n　　另外，还有一些专门的【3层】网络设备，也提供网络层的功能（参见本章节的后续小节）。  \n  \n\n![不见图 请翻墙](https://lh4.googleusercontent.com/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ)  \n（OSI 模型中，不同层次的协议实现）\n\n  \n\n### ◇IP 地址的格式及含义\n\n  \n　　当年设计阿帕网的时候，采用了【4字节】（32比特）来表示“网络层地址”（也就是 IP 地址）。  \n　　“IP 地址”的含义很重要，俺有必要解释一下：  \n　　咱们平时所说的 IP 地址，采用【点分十进制】来表示。就是把地址的4个字节，先翻译为十进制，然后每个字节用一个小数点分隔开（参见如下示意图）：  \n\n![不见图 请翻墙](https://lh5.googleusercontent.com/MCf0UTOAGLTbDJ5l46RlSHfidNm4PY7xqHrOBTP0P9OOneffxtC1B-VH_W2uBE7kCetsEMqTuLcS4niwj4MvqsXEA6QLeIvjTXQlGtBmgzL1d7VgrA5Na7YguV7OBKGzk9qvx_FrFHM)  \n（4字节 IP 地址：“二进制”与“点分十进制”的对照示意图）\n\n  \n　　“IP 地址”的32比特，分为两部分：第1部分用来标识【子网】，第2部分用来标识该子网中的【主机】。  \n　　这两部分各占用多少比特，是不确定的。在这种情况下，“操作系统协议栈”如何知道哪些比特标识“子网”，哪些比特标识“主机”捏？奥妙在于【子网掩码】。所以，大伙儿在给系统配置 IP 地址的时候，通常都需要再设置一个【子网掩码】，就这个用途。  \n  \n\n### ◇IP 地址枯竭，及其解决方法\n\n  \n　　前一个小节提到：IP地址包含【4字节】（32比特）。因此，最多只能表示【2的32次方】（42亿左右）的不同地址。考虑到还有很多地址保留给特殊用途，实际可用地址远远不到42亿。  \n　　到了如今，全球网民都已经几十亿了，IP 地址开始枯竭。咋办捏？为了解决这个问题，发展出若干技术手段。简单说一下最常见的几种手段：  \n  \n　　**IPv6**  \n　　名气最大（最多人知道）的技术手段，大概是 IPv6 了。这招想要一劳永逸地解决地址枯竭的问题，采用了16字节（128比特）来表示 IP 地址。  \n　　设计 IPv6 的人自豪地宣称：即使给地球上的每一粒沙子分配一个 IPv6 地址，依然绰绰有余（确实没有吹牛，“2的128次方”是天文数字）。  \n　　但 IPv6 的缺点在于，【无法】向下兼容原有的 IP 协议（原有的协议叫“IPv4”）。IPv6 的普及一直比较慢，这是主要原因。  \n  \n　　**代理服务器（proxy）**  \n　　一看到代理，很多人就想到翻墙。其实它也可以用来解决“地址枯竭”的问题。  \n　　比如说，某个公司有100人，100台电脑。如果每台电脑都分配公网 IP 地址，就要消耗100个公网地址（太浪费啦）。  \n　　可以只申请一个公网 IP，然后在内网搞一个代理服务器，公网 IP 分配给它（代理服务器有两个网卡，一个接内网，一个接公网）。然后在其它电脑上设置代理，指向这台代理服务器，就都可以上外网啦。  \n　　（注：在本文的末尾有一个 ★杂项 的章节，会专门聊一下“代理”这个话题）  \n  \n　　**[网络地址转换](https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2)（NAT）**  \n　　前面 proxy 那招有个缺点：内网的每台电脑里面的每个上网软件，都要单独设置代理。实在太麻烦啦！  \n　　后来就发明了某种更牛逼的招数——网络地址转换（洋文是“Network Address Translation”，简称 NAT）。  \n　　用了这招，还是只要申请一个公网 IP，分配给内网的网关（网关有两个网卡，一个接内网，一个接公网）。然后在内网的网关配置 NAT 功能，自动就可以让内网的每台电脑访问外网。  \n　　在[这篇博文](https://program-think.blogspot.com/2012/12/system-vm-5.html)，俺介绍了虚拟机的几种“网卡模式”，其中有一种模式叫做【NAT 模式】，就是指这个玩意儿。  \n　　采用了 NAT 技术之后，可能会对某些应用软件（尤其是 P2P 类型的）造成兼容性问题，于是又发明了一些“NAT 穿透技术”（[NAT traversal](https://en.wikipedia.org/wiki/NAT_traversal)）。这类技术有好几种，如果有空的话，俺会单独写教程介绍。  \n  \n　　**其它解决方法**  \n　　关于“IPv4 地址空间耗尽”，解决方法肯定不止上面这几招。限于篇幅，就此打住。更多的讨论参见维基百科的“[这个链接](https://en.wikipedia.org/wiki/IPv4_address_exhaustion)”。  \n  \n\n### ◇网络层相关的【网络设备】\n\n  \n　　**[路由器](https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8)（router）**  \n　　（前面章节聊“路由原理”的时候，已经介绍过它；这里就不再浪费口水啦）  \n  \n　　**3层交换机（Layer 3 switching）**  \n　　“3层交换机”是在“2层交换机”的基础上，增加了对网络层的处理。因此，它可以做到类似路由器的效果——在几个子网之间转发数据。  \n　　与路由器的差别在于——“3层交换机”链接的几个子网是【同种】网络；而路由器可以连接【异种】网络。  \n　　从上面这句话看，“3层交换机”的能力显然不如“路由器”。既然已经有“路由器”，为啥还要发明“3层交换机”捏？这就要说到【单臂路由器】的弊端。  \n　　对于企业内网的“2层交换机”，通常都支持 VLAN 功能。通俗地说：可以在交换机中划分多个【虚拟子网】。其实这些子网的中所有的电脑，都还是接入这台交换机，只不过这些子网配置了不同的网络地址。对于同一个 VLAN 内部的通讯，“2层交换机”自己就可以搞定（只需要用到2层协议）；但对于【跨】VLAN 主机之间的通讯，“2层交换机”就没戏啦（它没有路由功能）。因此，就必须在它旁边外加一个路由器，形成如下拓扑结构。在这个拓扑中，路由器只与单个设备（2层交换机）相连，所以称之为“单臂”。  \n　　请注意：如下示意图只画了两台电脑，位于两个 VLAN。实际上可能有很多个 VLAN，每个里面有几十台电脑。于是，交换机与路由器之间的传输通道就会成为瓶颈——【跨】VLAN 的任意两台电脑通讯，数据包都要到路由器那里兜一圈。为了消除这种瓶颈，才发明了“3层交换机”——把路由功能直接集成到交换机内部。  \n  \n\n![不见图 请翻墙](https://lh4.googleusercontent.com/FTo8x8w2DwhPaz10fDJ2LdwywSaaPLlciSaH4wg0HY_sHKT0MHvDN6k2ZxAvyzojuzGpklzg7hBV1iolR40_1_LaxIqYeOa1lo0IWQrb0_cpJzoGQbdZCu7fPcgieH897MuEPwlA5Gw)  \n（“单臂路由器”的拓扑结构）\n\n  \n　　**[无线热点](https://zh.wikipedia.org/wiki/%E7%84%A1%E7%B7%9A%E6%8E%A5%E5%85%A5%E9%BB%9E)（Wireless Access Point）**  \n　　“无线热点”通常用来提供无线接入，使得某个【无线】设备能接入到某个【有线】网络中。一般来说，热点都内置了路由功能，那么它就是“无线路由器”，对应到“3层”（网络层）。反之，如果没有路由功能，它就是“网桥”，属于“2层”（链路层）。  \n  \n\n### ◇网络层相关的【软件工具】\n\n  \n　　**[ping](https://en.wikipedia.org/wiki/Ping_\\(networking_utility\\))**  \n　　这个命令，很多人应该都知道。早在 Win9x 就有这个命令了。它使用（网络层的）ICMP 协议来测试某个远程主机是否可达。  \n　　提醒一下：  \n　　如果 ping 命令显示某个 IP 地址不可达，有很多种情况。比如说：  \n\n> 这个 IP 地址对应的主机已经关机  \n> 这个 IP 地址对应的主机已经断线  \n> 这个 IP 地址对应的主机拒绝响应 ICMP 协议  \n> 从你本机到这个 IP 地址之间，有某个防火墙拦截了 ICMP 协议  \n> ......\n\n  \n　　**[traceroute](https://en.wikipedia.org/wiki/Traceroute)**  \n　　这是一个通用的工具，用来测试路由。很早以前的 Windows 就已经内置了它，命令是 `tracert`。在 POSIX（Linux＆UNIX）上通常叫 `traceroute`  \n　　你可以用这个命令，测试你本机与互联网另一台主机之间的路由（也就是：从你本机到对方主机，要经过哪些路由器）  \n  \n  \n\n## ★传输层：概述\n\n  \n\n### ◇传输层的必要性\n\n  \n　　**屏蔽“有连接 or 无连接”的差异**  \n　　（上一个章节提到）网络层本身已经屏蔽了【异种网络】的差异（比如“以太网、ATM、帧中继”之间的差异），而且网络层也屏蔽了路由的细节。但网络层本身还有一个差异，也就是网络层的两种交换技术：电路交换（有连接） VS 分组交换（无连接）。  \n　　前面章节也提到了：上述两种交换技术各有很多支持者，并分裂为两大阵营。当年设计 OSI 模型的时候，为了保持中立性与通用性，并没有强制规定“网络层”必须采用何种交换机制。  \n　　对于开发网络软件的程序员来说，当然不想操心“网络层用的是哪一种交换机制”。因此，需要对网络层的上述差异再加一个抽象层（也就是“传输层”）。  \n  \n　　**从“主机”到“进程”**  \n　　前面介绍的“网络层”，其设计是面向主机（电脑）。“网络层地址”也就是某个主机的地址。  \n　　而“传输层”是面向【进程】滴！因为传输层要提供给【网络软件】使用，而网络软件打交道的对象是【另一个网络软件】。因此，传输层必须在“网络层地址”的基础上，再引入某种新的标识，用来区分同一台主机上的不同【进程】。  \n  \n\n### ◇传输层的特殊性\n\n  \n　　在 OSI 7层模型中，传输层正好居中。这是一个很特殊的位置。  \n　　OSI 模型最下面3层，与【网络设备】比较密切。这里面所说的“网络设备”，既包括那些独立的主机（比如“路由器、交换机、等”），也包括电脑上的硬件（比如“网卡”）。  \n　　OSI 模型最上面3层，与【网络软件】比较密切（或者说，与“用户的业务逻辑”比较密切）。  \n　　而中间的传输层，正好是承上启下。对于开发应用软件的程序猿/程序媛，“传输层”是他们能感知的最低一层。  \n  \n\n### ◇传输层的【端口】\n\n  \n　　刚才谈“传输层的必要性”，提到说——“网络层地址”只能标识【主机】，而传输层必须要能标识【进程】。为了达到这个目的，于是就引入了“传输层端口”这个概念（为了打字省力，后续讨论简称为“端口”）。  \n　　在 OSI 模型中，“端口”的官方称呼是“传输服务访问点”（洋文缩写 TSAP）。但是作为程序员，俺已经习惯于“端口”这个称呼。后续介绍依然用“端口”一词。  \n　　当程序员使用传输层提供的 API 开发网络软件时，通常把“端口”与“网络地址”一起使用（构成“二元组”），就可以定位到某个主机上的某个进程。  \n  \n  \n\n## ★传输层：具体实例\n\n  \n\n### ◇传输层的【协议】\n\n  \n　　为了让程序员可以更爽地使用传输层来开发网络软件，传输层既要提供“有连接”的风格，也要提供“无连接”的风格。关于这两种风格的对比，前面已经聊过，这里不再浪费口水。  \n　　具体到“互联网协议族”，有两个主要的传输层实现，分别是 TCP ＆ UDP（前者是“有连接”，后者是“无连接”）。  \n　　除了 TCP ＆ UDP，“互联网协议族”还提供了其它一些传输层协议。因为比较冷门，俺就不介绍啦。  \n  \n\n### ◇传输层的【协议实现】\n\n  \n　　对于电脑主机（含移动设备），传输层的协议实现通常包含在操作系统自带的网络模块中（也就是“操作系统协议栈”）。具体参见如下示意图。  \n　　另外，还有一些专门的【4层】网络设备，也提供传输层的功能（参见后续的小节）。  \n  \n\n![不见图 请翻墙](https://lh4.googleusercontent.com/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ)  \n（OSI 模型中，不同层次的协议实现）\n\n  \n\n### ◇套接字（socket API）\n\n  \n　　前面说了：传输层是面向程序员（让他们可以更方便地开发网络软件）。因此，就需要提供一些封装传输层的【库】（API）。程序员只需要调用这些【库】，就可以使用传输层的协议进行通讯啦。  \n　　影响力最大的传输层封装库，当然是 socket API。它来自加州大学伯克利分校。  \n　　在互联网诞生初期，伯克利分校开发了一个 UNIX 操作系统的的变种，叫做“伯克利 UNIX 发行版”（BSD Unix），也就是如今 BSD 操作系统的前身。伯克利发行版内置了一套用来进行网络编程的 API，当时叫做“伯克利套接字”（[Berkeley sockets](https://en.wikipedia.org/wiki/Berkeley_sockets)）。由于这套 API 用起来很方便，很多其它的 UNIX 变种也移植了这套 API，于是就逐渐成了业界的事实标准。到了上世纪90年代，Windows ＆ Linux 也都提供了这套 API。  \n　　由于大部分读者不是程序员，“套接字”这个话题就到此为止。如果你是个程序员，并且对网络编程感兴趣，可以参考[俺的电子书清单](https://github.com/programthink/books)，其中有一个分类目录是【IT 类 / 软件开发 / 网络相关】。  \n  \n\n### ◇传输层相关的【网络设备】\n\n  \n　　**4层交换机（Layer 4 switching）**  \n　　前面已经介绍了“3层交换机”，“4层交换机”是其进一步的改良，可以识别传输层的协议，获取 TCP or UDP 的端口号。  \n　　有了这个能力，网管就可以在这种交换机上配置一些管理策略。比如说：（根据传输层端口号）过滤掉某种流量，或者对某种流量设置转发的优先级。  \n  \n　　**状态防火墙（[stateful firewall](https://en.wikipedia.org/wiki/Stateful_firewall)）**  \n　　网络防火墙分好几种，大部分属于这种。它能完全处理 TCP 协议的状态，显然它属于“4层”（传输层）。  \n  \n\n### ◇传输层相关的【软件工具】\n\n  \n　　**[netcat](https://en.wikipedia.org/wiki/Netcat) 家族**——传输层的“瑞士军刀”  \n　　关于 netcat，俺已经写过一篇比较详细的教程：《[扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵”](https://program-think.blogspot.com/2019/09/Netcat-Tricks.html)》。看完这篇教程，你肯定能体会它功能的强大——很多与 TCP/UDP 相关的事情，都可以用 netcat 搞定。  \n　　另外，netcat 还有很多衍生品（衍生的开源项目），构成一个丰富的 netcat 家族。在上述教程也有介绍。  \n  \n　　**netstat ＆ ss**  \n　　Windows 和 POSIX（Linux＆UNIX）都有一个 `netstat` 命令，可以查看当前系统的 TCP/UDP 状态（包括当前系统开启了哪些监听端口）。  \n　　另外，Linux 上还有一个 `ss` 命令，功能更强（但这个命令在 Windows 上默认没有）  \n  \n　　**[nmap](https://en.wikipedia.org/wiki/Nmap)**  \n　　这是最著名的开源的扫描器，可以扫描远程主机监听了哪些传输层端口（注：前面提到的“netcat 家族”也可以干这事儿）  \n　　`nmap` 的功能很强，“端口扫描”只是其功能之一。  \n  \n  \n\n## ★业务层（OSI 上三层）：概述\n\n  \n　　一不小心，这篇教程已经写了这么长。为了照顾那些有“阅读障碍”的读者，俺要稍微控制一下篇幅，就把 OSI 的【上三层】合在一起讨论。  \n　　前面的章节说过：【上三层】更接近于“网络软件”，对应的是应用软件的业务逻辑，因此俺统称为“业务层”。  \n　　注：有些书（比如《[计算机网络](https://docs.google.com/document/d/1XQwaAMzuGuvmq5fCiTDMrh_pTUpCHJJ5C17btTv8kdE/)》）会把 OSI 的上三层统称为“应用层”。由于 OSI 模型中本来就有一个“应用层”，俺认为这样容易搞混（尤其不利于技术菜鸟），所以另外起了一个“业务层”的名称。  \n  \n\n### ◇业务层的必要性\n\n  \n　　业务层显然是必要滴。因为传输层位于操作系统，它不可能去了解网络软件的业务逻辑。为了让网络软件能够相互通讯，肯定要在传输层之上再定义更高层的协议。  \n　　问题在于：网络软件千奇百怪，其业务逻辑各不相同，因此，“业务层如何设计”，【无】一定之规。有些软件只用一个协议来搞定所有的业务逻辑（只有一层）；有些软件会参考 OSI，把业务逻辑的协议分为三层；还有些软件可能会分出更多的层次。  \n　　再强调一下：业务层的协议如何分层，完全看具体的业务逻辑，不要生搬硬套任何现有的参考模型。  \n  \n\n### ◇会话层 ＆ 表示层 ＆ 应用层\n\n  \n　　对于大部分读者来说，【没必要】花时间去了解 OSI 最上面三层之间的区别。你只需把最上面三层视作【一坨】——他们都是与网络软件的业务逻辑密切相关滴。  \n　　那么，哪些人需要详细了解“这三层的差异”捏？  \n　　如果你是个程序员，并且你正好是开发【网络】软件，俺建议你了解一下 OSI 模型的最上面三层，有助于你更深刻地思考某些网络协议的设计。所谓的“更深刻”指的是：你不能光停留在 WHAT 层面，要提升到 HOW 甚至 WHY 层面（参见《[学习技术的三部曲：WHAT、HOW、WHY](https://program-think.blogspot.com/2009/02/study-technology-in-three-steps.html)》）  \n  \n  \n\n## ★业务层（OSI 上三层）：具体实例\n\n  \n\n### ◇业务层的【协议】\n\n  \n　　业务层的协议非常多。即使光把各种协议的名称列出来，也很费劲。所以俺就偷懒一下，只点评几个特别重要的协议。  \n  \n　　**HTTP 协议**  \n　　如果让俺评选最重要的业务层协议，俺首推 HTTP 协议。互联网的普及推动了 Web 的普及，而 Web 的普及使得 HTTP 成为信息时代的重要支柱。当你上网的时候，你看到的网页（HTML 页面）就是通过 HTTP 协议传输到你的浏览器上。  \n　　如今 HTTP 已经不仅仅用来展示网页，还有很多业务层的协议是建立在 HTTP 协议之上。比如说：如果你用 RSS 订阅俺的博客，RSS 阅读器需要调用 blogspot 博客平台提供的 RSS 接口，这些 RSS 接口就是基于 HTTP 协议传输滴。  \n　　考虑到本文的篇幅，俺不可能在这里细聊 HTTP 协议的规格，有兴趣的同学可以去看《[HTTP 权威指南](https://docs.google.com/document/d/1TgujhFUzyVlf1W5e48lSMTIwJuCTElvXw2LgQ_Ng0Cs/)》这本书。  \n  \n　　**SSL/TLS 协议**  \n　　最早的 HTTP 协议是【明文】滴；为了强化安全性，后来又设计了 SSL 协议，用来【加密】HTTP 流量；再后来，SSL 升级为 TLS（这俩是同义词）。如今经常看到的 HTTPS 相当于“HTTP over TLS”。  \n　　SSL/TLS 设计得比较优雅（很灵活），使得其它业务层的协议可以很方便地架构在 SSL/TLS 之上。这样的好处是：其它协议就不用自己再设计一套加密机制＆认证机制。  \n　　SSL/TLS 对于安全性很重要，因此俺专门写了一个系列教程（如下），详细介绍该协议的技术细节。  \n《[扫盲 HTTPS 和 SSL／TLS 协议](https://program-think.blogspot.com/2014/11/https-ssl-tls-0.html)》（系列）  \n  \n　　**域名相关的协议（DNS 及其它）**  \n　　域名相关的协议，也很重要。因为域名系统是整个互联网的基础设施。最早的域名查询协议是“DNS 协议”，由于这个协议【没有】加密，导致了一些安全隐患。比如 GFW 就利用 DNS 的这个弱点，搞“域名污染/域名投毒”。因此，后来又设计了一系列新的域名协议，引入了加密的机制。  \n　　关于这些协议的扫盲教程，可以参考如下几篇博文：  \n《[扫盲 DNS 原理，兼谈“域名劫持”和“域名欺骗／域名污染”](https://program-think.blogspot.com/2014/01/dns.html)》  \n《[对比4种强化域名安全的协议——DNSSEC，DNSCrypt，DNS over TLS，DNS over HTTPS](https://program-think.blogspot.com/2018/10/Comparison-of-DNS-Protocols.html)》  \n  \n\n### ◇业务层相关的【网络设备】\n\n  \n　　**应用层防火墙（[application firewall](https://en.wikipedia.org/wiki/Application_firewall)）**  \n　　前面提到了：大多数网络防火墙处于4层（状态防火墙），另外还有少数处于7层，也就是“应用层防火墙”（有时候也称之为“7层防火墙”）。  \n　　一般来说，这类防火墙具备了【深度包检测】（deep packet inspection，简称 DPI）的能力，可以分析应用层协议的【内容】。  \n　　简单说一下“深度包检测”：  \n　　如果某个网络设备，仅仅分析“应用层协议”本身，它还【不够格】称之为 DPI。为了做到 DPI，还要能理解应用层协议所承载的【内容】。  \n　　比如说：某人通过【明文】的 HTTP 协议从网上下载了一个 zip 压缩包。对于这个下载行为，那些做得好的 DPI 设备不光能识别出“HTTP 协议的内容是 ZIP 压缩包”，而且还能从 ZIP 压缩包中提取出里面的文件。  \n  \n　　**入侵检测（[intrusion detection system](https://en.wikipedia.org/wiki/Intrusion_detection_system)）**  \n　　一般来说，“入侵检测”如果不加定语，通常指“【网络】入侵检测”（洋文叫 NIDS）；另外还有一种“【主机】入侵检测”（洋文叫 HIDS）。HIDS 与本文无关。  \n　　“入侵检测”是一种网络安全设备，它通过嗅探（sniffer）的方式抓取网上的数据包，然后进行分析，尝试发现网络中是否存在黑客/骇客的入侵的行为。故名“入侵检测”。  \n　　由于 IDS 需要理解【应用层】（7层）的内容，因此它与“应用层防火墙”有个共同点，需要具备某种程度的 DPI（深度包检测）能力。它俩的一大差异是【部署方式】。  \n　　考虑到很多读者是 IT 外行，简单说一下“旁路部署”——  \n如果你学过中学物理，应该知道电路有“串联 ＆ 并联”。所谓的“旁路部署”类似于电路中的【并联】。通俗地说：IDS 是【并联】部署，防火墙是【串联】部署。  \n  \n　　**GFW（Great Firewall）**  \n　　本博客已经写了很多翻墙教程，大伙儿肯定都知道 GFW 了。  \n　　由于“Great Firewall”中有“Firewall”字样，很多天朝网民【误以为】GFW 是防火墙，其实不然！GFW 本质上就是 IDS——其部署方式类似于 IDS（旁路部署），其工作方式有很大一部分也类似于 IDS（当然啦，GFW 的功能比 IDS 更多）。  \n　　大约七八年前，就有热心读者建议俺写一篇技术博文，介绍 GFW 的工作原理。由于俺比较懒，拖到今年（2021）都没动手，很惭愧 :(  \n  \n  \n\n## ★杂项\n\n  \n　　有些概念，并不属于某个特定的层次，单独放到这个章节。  \n  \n\n### ◇VPN（[virtual private network](https://en.wikipedia.org/wiki/Virtual_private_network)）\n\n  \n　　咱们天朝的网民使用 VPN，一多半是为了翻墙。其实 VPN 的本意（如其名称所示）是为了提供某种虚拟化的私有的网络，让身处异地的多个人，可以用 VPN 构建出一个虚拟的内网，从而能在这个内网中协同工作。  \n　　VPN 的类型很多，使用的技术也各不相同，因此 VPN 对应的 OSI 层次很宽（“1层”到“6层”）。俺到维基百科剽窃了如下这张图，让你见识一下 VPN 的多样性。  \n  \n\n![不见图 请翻墙](https://lh4.googleusercontent.com/qXbaBYZBvZ5k6gn4mp2M0dCYFW1rK_HR3JTCRYoWpGyNo9AZ6i90LgQzZgvL0OqImrf6j5FNAbDQDHG5k9I4iHVsm7FCSSHYhCV0yKJsz5vAH9Fil_4ZxclOoHSjlUH2aLA8Gv3hMcU)  \n（名目繁多的 VPN，分类示意图）\n\n  \n\n### ◇代理（proxy）\n\n  \n　　那些经常翻墙的同学，对“代理”应该都很熟悉了。“代理”与 VPN 类似，一开始并不是用来翻墙滴，“翻墙”只是这俩的副业。  \n  \n　　**代理服务器（proxy server）**  \n　　“代理服务器”部署在“客户端 ＆ 服务端”之间，起到某种“中介”的作用。“代理服务器”的类型有很多，干的事情各不相同。  \n  \n\n![不见图 请翻墙](https://lh6.googleusercontent.com/wklKf5goUVXTzmjccmfjIRpKKxZd-9vhT_0HMy3KknjAU7Oxj0GPgC7jjjO0BAfl6f-fapaBgHSp0mtsE1sS6ZyypE-ESB4idMi-ReKKU17Z1k_oVKupiOQcX3uQTlfU_P0VjoiZnG4)  \n（“代理服务器”的简单示意图）\n\n  \n　　**代理客户端（proxy client）**  \n　　早期的代理服务器，【不】需要“代理客户端”。因为早期的“代理服务器”支持的是【标准协议】。比如“HTTP proxy server”支持的是标准 HTTP协议，而用户的电脑上，已经有浏览器（原生支持 HTTP 协议）。这种情况下，自然不需要再有“代理客户端”。  \n　　后来，为了满足某些特殊需求（比如翻墙），“代理服务器”必须使用某种特殊的（非标准的）协议。因此，就必须在用户的环境中安装“代理客户端”。对于翻墙来说，你装的翻墙软件，相当于“代理客户端”。  \n  \n　　**代理的层次**  \n　　“代理”也分不同的层次。比较常见的有如下几种：  \n\n> TCP 代理（TCP 端口转发）——4层（传输层）  \n> SOCKS 代理——5层（会话层）  \n> HTTP 代理——7层（应用层）  \n> ......\n\n  \n\n### ◇网关（[gateway](https://en.wikipedia.org/wiki/Gateway_\\(telecommunications\\))）\n\n  \n　　前面的某些章节，已经稍微提及了“网关”这个概念，但还没有具体介绍它。  \n　　严格来讲，“网关”是一个逻辑概念，【不要】把它当成具体的网络设备。充当“网关”的东东，可能是：路由器 or XX层交换机 or XX层防火墙 or 代理服务器 ......  \n　　“网关”也分不同的层次。如果不加定语，通常指的是“3层网关”（网络层网关）。列几种比较常见的，供参考：  \n\n> 路由器充当网关——3层（网络层）  \n> 3层交换机充当网关——3层（网络层）  \n> 4层交换机充当网关——4层（传输层）  \n> 应用层防火墙充当网关——7层（应用层）  \n> 代理服务器充当网关——（取决于代理的层次，参见前一个小节）  \n> ......\n\n  \n\n### ◇隧道协议（[tunneling protocol](https://en.wikipedia.org/wiki/Tunnelling_protocol)）\n\n  \n　　所谓的“隧道协议”，通俗地说就是：用某种协议包裹另一种协议，以满足某些特殊的需求。  \n　　看到这里，估计某些同学会感到纳闷——因为俺在本文开头介绍“协议栈”的时候提到说：相邻的两层协议，下层会包裹上层。“隧道协议的包裹”与“上下层协议的包裹”，差别在哪捏？  \n　　俺来解释一下：  \n　　“隧道协议”可以做到更灵活的包裹——既可以对层次相隔很远的协议进行包裹，也可以对同一层的协议进行包裹，甚至可以“倒挂”——所谓的“倒挂”就是让【上】层反过来包裹【下】层。  \n　　举例：  \n　　俺曾经写过一篇《[如何让【不支持】代理的网络软件，通过代理进行联网（不同平台的 N 种方法）](https://program-think.blogspot.com/2019/04/Proxy-Tricks.html)》，其中介绍了“HTTP 代理”的两种模式：“转发模式 ＆ 隧道模式”。对于“HTTP 代理”的隧道模式，可以实现【TCP over HTTP】（把 TCP 协议打包到 HTTP 协议内部），这就是刚才所说的“倒挂”。  \n　　另外，VPN 小节的那张图中，有些类型的 VPN 就是用“隧道协议”的机制实现。  \n  \n\n### ◇（其它杂项）\n\n  \n　　可能还有一些杂七杂八的东东，没来得及聊。如果你觉得有些【网络相关】的概念，不太明白，欢迎到博客留言，进行反馈。  \n　　俺会根据大伙儿的反馈，再对这篇教程进行补充。  \n  \n  \n\n## ★参考书目\n\n  \n　　如下几本书，都在[俺的网盘](https://github.com/programthink/books)上分享了电子版。  \n  \n\n| 中文书名 | 英文书名 | 作者 |\n| --- | --- | --- |\n| 《[计算机网络](https://docs.google.com/document/d/1XQwaAMzuGuvmq5fCiTDMrh_pTUpCHJJ5C17btTv8kdE/)》 | 《Computer Networks》 | [Andrew Tanenbaum](https://en.wikipedia.org/wiki/Andrew_S._Tanenbaum)  \nDavid Wetherall |\n| 《[计算机网络——自顶向下方法](https://docs.google.com/document/d/1tlbsKWyddVLeB3HSWUiq7KtkltLeClIbPtkyN6642O4/)》 | 《Computer Networking——A Top-Down Approach》 | [James Kurose](https://en.wikipedia.org/wiki/Jim_Kurose)  \n[Keith Ross](https://en.wikipedia.org/wiki/Keith_W._Ross) |\n| 《[TCP-IP 详解](https://docs.google.com/document/d/1Fw2wSr-MgNm1d_M6F-rF1t_n3LwFWWBHrJt6vcYGta4/)》 | 《TCP-IP Illustrated》 | [Richard Stevens](https://zh.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E5%8F%B2%E8%92%82%E6%96%87%E6%96%AF) |\n| 《[UNIX 网络编程](https://docs.google.com/document/d/1eB4BLE9PDXDfrb-ioXNfrHlOthMqUe0MXs8PmRsm3Os/)》 | 《UNIX Network Programming》 | [Richard Stevens](https://zh.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E5%8F%B2%E8%92%82%E6%96%87%E6%96%AF) |\n| 《[HTTP 权威指南](https://docs.google.com/document/d/1TgujhFUzyVlf1W5e48lSMTIwJuCTElvXw2LgQ_Ng0Cs/)》 | 《HTTP——The Definitive Guide》 | David Gourley  \nBrian Totty  ',25,'开发','计算机知识,计算机网络',1,0,0,0,'2024-09-05 23:21:32','2025-09-05 23:21:32');
/*!40000 ALTER TABLE `tb_blog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_blog_category`
--

DROP TABLE IF EXISTS `tb_blog_category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_blog_category` (
  `category_id` int NOT NULL AUTO_INCREMENT COMMENT '分类表主键',
  `category_name` varchar(50) NOT NULL COMMENT '分类的名称',
  `category_icon` varchar(50) NOT NULL COMMENT '分类的图标',
  `category_rank` int NOT NULL DEFAULT '1' COMMENT '分类的排序值 被使用的越多数值越大',
  `is_deleted` tinyint NOT NULL DEFAULT '0' COMMENT '是否删除 0=否 1=是',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`category_id`)
) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_blog_category`
--

LOCK TABLES `tb_blog_category` WRITE;
/*!40000 ALTER TABLE `tb_blog_category` DISABLE KEYS */;
INSERT INTO `tb_blog_category` VALUES (24,'日常随笔','/admin/dist/img/category/06.png',42,0,'2018-11-12 10:43:21'),(25,'开发','/admin/dist/img/category/16.png',9,0,'2021-02-24 19:30:32');
/*!40000 ALTER TABLE `tb_blog_category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_blog_comment`
--

DROP TABLE IF EXISTS `tb_blog_comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_blog_comment` (
  `comment_id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `blog_id` bigint NOT NULL DEFAULT '0' COMMENT '关联的blog主键',
  `commentator` varchar(50) NOT NULL DEFAULT '' COMMENT '评论者名称',
  `email` varchar(100) NOT NULL DEFAULT '' COMMENT '评论人的邮箱',
  `website_url` varchar(50) NOT NULL DEFAULT '' COMMENT '网址',
  `comment_body` varchar(200) NOT NULL DEFAULT '' COMMENT '评论内容',
  `comment_create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '评论提交时间',
  `commentator_ip` varchar(20) NOT NULL DEFAULT '' COMMENT '评论时的ip地址',
  `reply_body` varchar(200) NOT NULL DEFAULT '' COMMENT '回复内容',
  `reply_create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '回复时间',
  `comment_status` tinyint NOT NULL DEFAULT '0' COMMENT '是否审核通过 0-未审核 1-审核通过',
  `is_deleted` tinyint DEFAULT '0' COMMENT '是否删除 0-未删除 1-已删除',
  PRIMARY KEY (`comment_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_blog_comment`
--

LOCK TABLES `tb_blog_comment` WRITE;
/*!40000 ALTER TABLE `tb_blog_comment` DISABLE KEYS */;
INSERT INTO `tb_blog_comment` VALUES (1,6,'哈哈哈','3496655347@qq.com','','点赞，好文','2021-02-25 18:37:53','','','2021-02-25 18:37:53',1,1),(2,11,'张三','123456@qq.com','','这是一条认真的评论 哈哈','2021-03-01 18:36:16','','','2021-03-01 18:36:16',1,0);
/*!40000 ALTER TABLE `tb_blog_comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_blog_tag`
--

DROP TABLE IF EXISTS `tb_blog_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_blog_tag` (
  `tag_id` int NOT NULL AUTO_INCREMENT COMMENT '标签表主键id',
  `tag_name` varchar(100) NOT NULL COMMENT '标签名称',
  `is_deleted` tinyint NOT NULL DEFAULT '0' COMMENT '是否删除 0=否 1=是',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`tag_id`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_blog_tag`
--

LOCK TABLES `tb_blog_tag` WRITE;
/*!40000 ALTER TABLE `tb_blog_tag` DISABLE KEYS */;
INSERT INTO `tb_blog_tag` VALUES (1,'java',0,'2021-02-24 10:24:58'),(2,'数据结构',0,'2021-02-24 10:24:58'),(3,'计算机网络',0,'2021-02-24 10:24:58'),(4,'操作系统',0,'2021-02-24 10:24:58'),(5,'博客',0,'2021-02-24 19:37:11'),(6,'hugo',0,'2021-02-24 19:37:11'),(7,'idea',0,'2021-02-24 19:39:06'),(8,'javaScript',0,'2021-02-24 19:41:27'),(10,'ssh',0,'2021-02-24 19:49:45'),(11,'visio',0,'2021-02-24 19:51:31'),(12,'mysql',0,'2021-02-24 19:54:21'),(13,'python',0,'2021-02-24 19:54:21'),(14,'selenium',0,'2021-02-24 19:54:21'),(15,'markdown',0,'2021-02-24 19:56:37'),(16,'github',0,'2021-02-24 19:57:29'),(17,'123456',0,'2021-03-01 18:28:02'),(18,'555',1,'2021-03-02 16:09:17'),(19,'4566854787',0,'2021-03-02 18:01:06'),(20,'hdgsajhgdjha',0,'2021-03-02 18:04:16'),(21,'计算机知识',0,'2025-09-05 23:21:32');
/*!40000 ALTER TABLE `tb_blog_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_blog_tag_relation`
--

DROP TABLE IF EXISTS `tb_blog_tag_relation`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_blog_tag_relation` (
  `relation_id` bigint NOT NULL AUTO_INCREMENT COMMENT '关系表id',
  `blog_id` bigint NOT NULL COMMENT '博客id',
  `tag_id` int NOT NULL COMMENT '标签id',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '添加时间',
  PRIMARY KEY (`relation_id`)
) ENGINE=InnoDB AUTO_INCREMENT=313 DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_blog_tag_relation`
--

LOCK TABLES `tb_blog_tag_relation` WRITE;
/*!40000 ALTER TABLE `tb_blog_tag_relation` DISABLE KEYS */;
INSERT INTO `tb_blog_tag_relation` VALUES (281,1,1,'2021-02-24 10:24:58'),(282,2,1,'2021-02-24 10:24:58'),(283,2,15,'2021-02-24 10:24:58'),(284,3,1,'2021-02-24 10:24:58'),(285,3,12,'2021-02-24 19:37:11'),(286,7,6,'2021-02-24 19:37:11'),(287,4,7,'2021-02-24 19:39:06'),(288,5,11,'2021-02-24 19:41:27'),(289,6,12,'2021-02-24 19:42:44'),(290,6,13,'2021-02-24 19:43:55'),(291,6,14,'2021-02-24 19:46:46'),(292,7,1,'2021-02-24 19:49:45'),(293,8,10,'2021-02-24 19:50:38'),(294,9,13,'2021-02-24 19:51:31'),(295,10,16,'2021-02-24 19:52:31'),(296,11,1,'2021-02-24 19:54:21'),(297,11,13,'2021-02-24 19:54:21'),(302,13,17,'2021-03-01 18:28:02'),(303,12,1,'2021-03-01 18:44:21'),(304,12,4,'2021-03-01 18:44:21'),(305,12,2,'2021-03-01 18:44:21'),(306,12,3,'2021-03-01 18:44:21'),(307,14,19,'2021-03-02 18:01:06'),(310,15,20,'2021-03-02 18:12:46'),(311,16,3,'2025-09-05 23:21:32'),(312,16,21,'2025-09-05 23:21:32');
/*!40000 ALTER TABLE `tb_blog_tag_relation` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_config`
--

DROP TABLE IF EXISTS `tb_config`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_config` (
  `config_name` varchar(100) NOT NULL DEFAULT '' COMMENT '配置项的名称',
  `config_value` varchar(200) NOT NULL DEFAULT '' COMMENT '配置项的值',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`config_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_config`
--

LOCK TABLES `tb_config` WRITE;
/*!40000 ALTER TABLE `tb_config` DISABLE KEYS */;
INSERT INTO `tb_config` VALUES ('footerAbout','个人博客','2018-11-11 20:33:23','2021-02-26 02:36:45'),('footerCopyRight','2021 vigilr','2018-11-11 20:33:31','2021-02-26 02:36:45'),('footerICP','冀ICP备66666666号-2','2018-11-11 20:33:27','2021-02-26 02:36:45'),('footerPoweredBy','https://github.com/eternidad33','2018-11-11 20:33:36','2021-02-26 02:36:45'),('footerPoweredByURL','https://github.com/eternidad33','2018-11-11 20:33:39','2021-02-26 02:36:45'),('websiteDescription','MyBlog是SpringBoot2+Thymeleaf+Mybatis建造的个人博客网站','2018-11-11 20:33:04','2021-02-26 02:36:11'),('websiteIcon','/admin/dist/img/favicon.png','2018-11-11 20:33:11','2021-02-26 02:36:11'),('websiteLogo','/admin/dist/img/logo2.png','2018-11-11 20:33:08','2021-02-26 02:36:11'),('websiteName','MyBlog','2018-11-11 20:33:01','2021-02-26 02:36:11'),('yourAvatar','/admin/dist/img/f.jpg','2018-11-11 20:33:14','2021-02-26 02:36:39'),('yourEmail','3496655347@qq.com','2018-11-11 20:33:17','2021-02-26 02:36:39'),('yourName','vigilr','2018-11-11 20:33:20','2021-02-26 02:36:39');
/*!40000 ALTER TABLE `tb_config` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2025-09-08 20:33:16
